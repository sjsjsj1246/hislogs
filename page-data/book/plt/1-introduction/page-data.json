{"componentChunkName":"component---src-templates-blog-template-js","path":"/book/plt/1-introduction/","result":{"data":{"cur":{"id":"c19083f7-e382-558c-a2e1-e1ce0ea37b1d","html":"<blockquote>\n<p>이 책은 Michael L. Scott - Programming Language Pragmatics을 번역 정리한 글입니다.</p>\n</blockquote>\n<h1 id=\"1-introduction\" style=\"position:relative;\"><a href=\"#1-introduction\" aria-label=\"1 introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Introduction</h1>\n<p>최초의 전자 컴퓨터는 거대한 기계로 여러 개의 방을 가득 채우고, 공장만큼 전기를 소비했습니다. 1940년대에 수백만 달러의 비용이 들 정도였죠.</p>\n<p>이 기계를 사용한 프로그래머들은 기계어로 프로그래밍 했습니다. 기계어는 프로세스를 직접 제어하여 적절한 시간에 데이터를 한 장소에서 다른 곳으로 이동시키는 일련의 비트입니다. 이정도의 상세 수준에서 프로그램을 지정하는 것은 매우 지루한 작업입니다.</p>\n<p>다음 프로그램은 GCD 알고리즘을 x86머신의 기계어로 작성한 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"wasm\"><pre class=\"language-wasm\"><code class=\"language-wasm\"><span class=\"token number\">5589e553</span> 83ec0483 e4f0e831 <span class=\"token number\">00000089</span> c3e82a00 000039c3 74108db6 <span class=\"token number\">00000000</span> 39c37e13 29c339c3 75f6891c 24e86e00 00008b5d fcc9c329 d8ebeb90</code></pre></div>\n<p>사람들이 더 큰 프로그램을 쓰기 시작하면서, 실수할 확률이 적은 표기법이 필요했습니다.</p>\n<p><code class=\"language-text\">어셈블리어</code>는 연산이 니모닉 약어로 표현될 수 있도록 발명되었습니다. 당사의 GCD 프로그램은 x86 어셈블리어로 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tpushl %ebp\n\tmovl %esp, %ebp \n\tpushl %ebx\n\tsubl $4, %esp \n\tandl $-16, %esp \n\tcall getint \n\tmovl %eax, %ebx \n\tcall getint \n\tcmpl %eax, %ebx \n\tje C\nA:cmpl %eax, %ebx\n\tjle D\n\tsubl %eax, %ebx \nB:cmpl %eax, %ebx\n\tjne A\nC:movl %ebx, (%esp)\n\tcall putint\n\tmovl -4(%ebp), %ebx \n\tleave\n\tret\nD:subl %ebx, %eax\n\tjmp B</code></pre></div>\n<p>어셈블리어는 원래 니모닉과 기계어 명령어 사이의 일대일 대응으로 설계되었습니다. 어셈블러는 결국 프로그래머들이 공통 명령어 시퀀스에 대한 매개변수화된 약어를 정의할 수 있도록 정교한 “매크로 확장” 기능을 갖추게 되었다.</p>\n<p>어셈블리어와 기계어 사이의 대응은 명확하고 명확했습니다. 프로그래밍은 기계 중심으로 기획되었습니다. 각각의 다른 종류의 컴퓨터는 그들만의 어셈블리 언어로 프로그래밍되어야 했고, 프로그래머들은 기계가 실제로 실행할 명령어에 대해 생각했습니다.</p>\n<p>컴퓨터가 발전하고, 경쟁적인 디자인이 발전하는데, 모든 새로운 기계에 프로그램을 다시 작성해야 하는 것은 점점 더 힘들었습니다. 또한 대규모 어셈블리어 프로그램에서 인간이 세부 사항을 추적하는 것은 점점 더 어려워졌습니다.</p>\n<p>사람들은 기계 독립 언어, 특히 수치 계산(당시 가장 흔한 프로그램 유형)이 수학 공식과 더 가까운 형태로 표현될 수 있는 언어를 원하기 시작했습니다. 이러한 바람은 1950년대 중반 최초의 고급 프로그래밍 언어인 포트란(Fortran)의 원조 방언의 개발로 이어졌습니다. 리스프와 알골 등 다른 고급 언어들도 곧 그 뒤를 이었습니다.</p>\n<hr>\n<p>고급 언어에서 어셈블리어나 기계어로 번역하는 것은 <code class=\"language-text\">컴파일러</code>로 알려진 시스템 프로그램의 일입니다. 컴파일러는 소스가 고급 언어일 때 소스와 대상 연산 사이의 일대일 대응이 더 이상 존재하지 않기 때문에 어셈블러보다 더 복잡합니다.</p>\n<p>프로그래머들은 어느 정도 노력만 하면 컴파일러가 만들 수 있는 것보다 더 빨리 실행될 수 있는 어셈블리 언어 프로그램을 거의 항상 작성할 수 있었기 때문에 포트란은 처음에는 인기가 없었습니다. 하지만 시간이 지나면서 격차가 좁혀졌고, 결국 역전됐죠.</p>\n<p>하드웨어의 복잡성 증가(파이프라인, 다중 기능 단위 등)와 컴파일러 기술의 지속적인 향상은 최첨단 컴파일러가 사람보다 더 나은 코드를 생성하는 상황을 초래했습니다. 인간이 더 잘할 수 있는 경우에도 컴퓨터 속도와 프로그램 크기의 증가로 인해 프로그램의 원래 구성뿐만 아니라 이후의 프로그램 유지 관리(향상 및 수정)에서 프로그래머의 노력을 절약하는 것이 점점 더 중요해졌습니다. 인건비가 컴퓨팅 하드웨어 비용을 훨씬 능가하기 때문입니다.</p>\n<h2 id=\"11-the-art-of-language-design\" style=\"position:relative;\"><a href=\"#11-the-art-of-language-design\" aria-label=\"11 the art of language design permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 The Art of Language Design</h2>\n<p>오늘날 수천 개의 고급 프로그래밍 언어가 있으며 새로운 언어들이 계속해서 생겨나고 있습니다.</p>\n<p>왜 이렇게 많을까요? 다음과 같은 몇 가지 답이 있을 수 있습니다.</p>\n<p><strong>1. 진화</strong></p>\n<p>컴퓨터 과학은 아직 초기 학문입니다. 우리는 일을 하기 위한 더 나은 방법을 끊임없이 찾고 있습니다.</p>\n<p>1960년대 후반과 1970년대 초반에는 <code class=\"language-text\">structured programming</code> 혁명이 일어나 포트란, 코볼, 베이직과 같은 언어에 의해 goto 기반 제어 흐름에서 루프, 케이스(스위치) 문, 그리고 이와 유사한 상위 수준의 구조체들로 발전했습니다.</p>\n<p>1980년대 후반 알골, 파스칼, 에이다와 같은 언어들의 중첩된 블록 구조가 스몰토크, C++, 에펠과 같은 언어들의 객체 지향적 구조에 자리를 내주기 시작했습다.</p>\n<p>최근에는 파이썬과 루비와 같은 스크립트 언어가 빠른 개발을 위해 전통적인 컴파일 언어를 대체하기 시작했습니다.</p>\n<p><strong>2. 특수 용도</strong></p>\n<p>일부 언어는 특정 문제 영역에 맞게 설계되었습니다.</p>\n<ul>\n<li>다양한 리스프 방언은 심볼 데이터와 컴플렉스 데이터 구조를 조작하는 데 좋습니다.</li>\n<li>Icon과 Awk는 문자열 조작에 좋습니다.</li>\n<li>C는 로우 레벨 시스템 프로그래밍에 좋습니다.</li>\n<li>프롤로그는 데이터 간의 논리적 관계를 확인하는 데 좋습니다.</li>\n</ul>\n<p>이 언어들은 각각 더 넓은 범위의 작업에도 사용될 수 있지만, 그 전문성에 중점을 두고 있습니다.</p>\n<p><strong>3. 개인 선호도</strong></p>\n<p>사람마다 좋아하는 것이 다릅니다. 프로그래밍의 편파주의의 많은 부분은 단순히 취향의 문제입니다.</p>\n<ul>\n<li>어떤 사람들은 C의 진부함을 좋아하고, 어떤 사람들은 그것을 싫어합니다.</li>\n<li>어떤 사람들은 재귀적으로 생각하는 것이 당연하다고 생각하고, 다른 사람들은 반복하는 것을 선호합니다.</li>\n<li>어떤 사람들은 포인터로 작업하기를 좋아하고, 다른 사람들은 리스프, 자바, ML의 암묵적인 비참조를 선호한다.</li>\n</ul>\n<hr>\n<p>그러나 디자인된 많은 것들 중에서 단지 수십 개만이 널리 사용되고 있습니다.</p>\n<p>무엇이 언어를 성공적으로 만들까요? 다시 몇 가지 답이 있습니다.</p>\n<p><strong>1. 표현력</strong></p>\n<p>언어 기능은 특히 매우 큰 시스템의 경우 명확하고 간결하며 유지관리 가능한 코드를 작성하는 프로그래머의 능력에 큰 영향을 미칩니다. 예를 들어, 초기 버전의 베이직과 C++ 는 비교 불가능할 정도로 기능적 차이가 있습니다.. 표현력에 기여하는 요소들, 특히 추상화 기능이 이 책의 주요 초점입니다.</p>\n<p><strong>2. 초보자를 위한 사용 편의성</strong></p>\n<p>베이직은 트집 잡기는 쉽지만, 성공을 부정할 수는 없습니다. 그 성공의 일부는 그것의 매우 낮은 “학습 곡선” 때문이었습니다.</p>\n<p>파스칼은 여러 해 동안 프로그래밍 언어 입문 강좌에서 가르쳤는데, 그 이유는 적어도 다른 진지한 언어들에 비해 간결하고 배우기 쉬웠기 때문입니다. 세기가 바뀐 직후, 자바가 비슷한 역할을 하게 되었습니다. 자바는 파스칼보다 훨씬 복잡하지만, C++보다 간단합니다. 단순성에 대한 새로운 추구로, 최근 몇 년 동안 일부 입문 과정은 파이썬과 같은 스크립트 언어로 바뀌었습니다.</p>\n<p><strong>3. 구현 용이성</strong></p>\n<p>베이직은 낮은 학습 곡선뿐만 아니라 제한된 리소스로 작은 기계에서 쉽게 구현할 수 있었기 때문에 성공적이었습니다. 파스칼의 성공에 있어 가장 중요한 한 가지 요인은 파스칼의 디자이너인 니클라우스 워스가 파스칼 언어를 간단하고 휴대할 수 있는 구현체를 개발하여 전 세계 대학에 무료로 제공했다는 것입니다.</p>\n<p>자바와 파이썬 디자이너들은 그들의 언어를 원하는 거의 모든 사람들에게 무료로 제공하기 위해 비슷한 조치를 취했습니다.</p>\n<p><strong>4. 표준화</strong></p>\n<p>널리 사용되는 거의 모든 언어는 공식적인 국제 표준이나 (여러 스크립팅 언어의 경우) 하나의 표준 구현체를 가지고 있습니다. 언어와 광범위한 라이브러리 모두의 표준화는 플랫폼 간 코드의 이식성을 보장하기 위한 진정으로 효과적인 유일한 방법입니다.</p>\n<p>상대적으로 피폐한 것이 파스칼의 표준인데, 파스칼은 많은 프로그래머들에 의해 필수적인 기능들(별도 컴파일, 문자열, 정적 초기화, 랜덤 액세스 I/O)이 빠져있었고, 적어도 1980년대에 파스칼이 선호하던 언어의 하락에 부분적으로 책임이 있었습니다. 이러한 기능들 중 다수는 벤더마다 다른 방식으로 구현되었습니다.</p>\n<p><strong>5. 오픈 소스</strong></p>\n<p>오늘날 대부분의 프로그래밍 언어들은 적어도 하나의 오픈 소스 컴파일러나 인터프리터를 가지고 있지만, 일부 언어들, 특히 C는 자유롭게 배포되고 검토되고 커뮤니티 지원 컴퓨팅과 훨씬 더 밀접하게 연관되어 있습니다.</p>\n<p>C는 원래 1970년대 초 벨 연구소의 데니스 리치와 켄 톰슨이 오리지널 유닉스 운영 체제의 디자인과 함께 개발하였다. 수년간 유닉스는 세계에서 가장 휴대성이 좋은 운영 체제(학술적인 컴퓨터 과학을 위한 OS)로 발전하였으며, C는 이와 밀접한 관련이 있었습니다. C의 표준화와 함께 이 언어는 다양한 추가 플랫폼에서 사용할 수 있게 되었습니다. 주요 오픈 소스 운영 체제인 리눅스는 C로 작성되어 있습니다. 2015년 6월 현재 C와 그 후손들은 웹 페이지 참조, 도서 판매, 고용 목록, 오픈 소스 리포지토리 업데이트 등 다양한 언어 관련 온라인 콘텐츠의 절반 이상을 차지하고 있습니다.</p>\n<p><strong>6. 좋은 컴파일러</strong></p>\n<p>포트란이 성공한 것은 매우 우수한 컴파일러 덕분입니다. 부분적으로는 이것은 역사적 사고의 문제인데요. 포트란은 다른 무엇보다도 오래 존재했고, 회사들은 매우 빠른 코드를 생성하는 컴파일러를 만들기 위해 막대한 시간과 돈을 투자했습니다.</p>\n<p>그러나 언어 디자인의 문제이기도 합니다. 포트란 90 이전의 포트란 방언에는 빠른 코드를 생성하는 작업을 훨씬 복잡하게 만드는 재귀와 포인터가 없었습니다. 비슷한 맥락에서 일부 언어들(예: Common Lisp)은 프로그래머가 매우 큰 프로젝트를 관리할 수 있도록 도와주는 컴파일러와 지원 도구를 가지고 있기 때문에 부분적으로 성공을 거두었습니다</p>\n<p><strong>7. 경제, 후원, 그리고 이너시아</strong></p>\n<p>마지막으로 기술적 장점 외에도 성공에 큰 영향을 미치는 요소들이 있습니다. 강력한 후원자의 후원이 그 하나입니다. PL/I는 IBM에 의해 수명이 연장되었습니다. 코볼과 에이다는 미국 국방부에, C#는 마이크로소프트의 덕분에 성공을 이루었습니다.</p>\n<p>최근 몇 년 동안, Objective-C는 아이폰과 아이패드 앱의 공식 언어로 엄청난 인기를 누리고 있습니다. 라이프 사이클의 다른 한편에서는, 어떤 언어들은 설치 소프트웨어와 프로그래머 전문지식의 거대한 기반 때문에 더 나은 대안이 나온 후에도 오랫동안 널리 사용되고 있습니다. 예를 들어, 세계 금융 인프라의 대부분은 여전히 주로 코볼에서 작동합니다.</p>\n<p>분명히 언어가 “좋은”지 여부를 결정하는 단일 요소는 없습니다. 프로그래밍 언어를 연구할 때, 우리는 몇 가지 관점에서 문제를 고려해야 합니다. 특히, 우리는 프로그래머와 언어 구현자 모두의 관점을 고려할 필요가 있습니다.</p>\n<p>때로는 실행 속도를 원하는 것처럼 이러한 관점이 조화를 이룰 것입니다. 그러나 기능의 개념적 매력이 구현 비용과 균형을 이루므로 종종 충돌과 절충이 있을 수 있습니다.</p>\n<hr>\n<p>컴퓨팅 초기에는 시행자의 관점이 우세했습니다. 프로그래밍 언어는 컴퓨터에 무엇을 해야 하는지 알려주는 수단으로 발전했습니다. 그러나 프로그래머들에게 언어는 알고리즘을 표현하는 수단으로 더 적절하게 정의됩니다.</p>\n<p>자연어가 설명과 담론을 제약하듯이 프로그래밍 언어는 표현 가능한 것과 표현 불가능한 것을 제약하고 프로그래머가 생각할 수 있는 것에 심오하고 미묘한 영향을 미칩니다. Donald Knuth는 프로그래밍을 다른 인간에게 컴퓨터가 무엇을 하기를 원하는지 알려주는 예술로 간주해야 한다고 제안했습니다. 이 정의는 아마도 가장 좋은 종류의 타협을 할 것이다. <code class=\"language-text\">개념적 명확성</code>과 <code class=\"language-text\">실행 효율성</code> 모두 근본적인 관심사라는 것을 인정합니다. 이 책은 다루는 각각의 주제들의 개념적 측면과 실행적 측면을 동시에 고려함으로써 이러한 타협 정신을 포착하려고 시도할 것입니다.</p>\n<p>Figure 1.1 프로그래밍 언어의 분류</p>\n<ul>\n<li>Declarative\n<ul>\n<li>functional\n<ul>\n<li>Lisp/Scheme, ML, Haskell</li>\n</ul>\n</li>\n<li>dataflow\n<ul>\n<li>Id, Val</li>\n</ul>\n</li>\n<li>logic, constraint-based\n<ul>\n<li>Prolog, spreadsheets, SQL</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Imperative\n<ul>\n<li>von Neumann\n<ul>\n<li>C, Ada, Fortran</li>\n</ul>\n</li>\n<li>object-oriented\n<ul>\n<li>Smalltalk, Eiffel, Java</li>\n</ul>\n</li>\n<li>scripting\n<ul>\n<li>Perl, Python, PHP</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"12-the-programming-language-spectrum\" style=\"position:relative;\"><a href=\"#12-the-programming-language-spectrum\" aria-label=\"12 the programming language spectrum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2 The Programming Language Spectrum</h2>\n<p>현존하는 많은 언어들은 그들의 계산 모델에 따라 어족으로 분류될 수 있습니다. Figure 1.1은 공통의 가족 집합을 보여줍니다.</p>\n<p>최상위 분류는 컴퓨터가 해야 할 일에 초점을 맞추는 선언형 언어와 컴퓨터가 어떻게 해야 하는지에 초점을 맞추는 명령형 언어로 구분됩니다.\n선언형 언어는 명령형 언어보다 고수준이며, 프로그래머의 관점과 더 일치하지만 실행자의 관점과는 덜 일치합니다. 명령형 언어는 주로 성능상로 우세합니다.</p>\n<p>선언형 언어의 설계에는 “관련없는” 구현 세부 사항에서 벗어나고자 하는 욕구와 최소한 알고리즘의 개요를 제어하기 위해 세부 사항에 충분히 가까이 있어야 할 필요성 사이에 긴장감이 있습니다. 효율적인 알고리즘의 설계는 결국 컴퓨터 과학의 많은 부분에 관한 것입니다.</p>\n<p>어떤 문제 영역에서는 컴파일러들이 매우 높은 수준의 추상화에서 언급된 문제에 대한 좋은 알고리즘을 발견하기를 기대할 수 있습니다. 그러나 컴파일러가 좋은 알고리즘을 찾을 수 없는 도메인에서 프로그래머는 명시적으로 알고리즘을 지정할 수 있어야 합니다.\n선언적 어족 및 명령적 어족에는 몇 가지 중요한 하위 어족들이 있습니다.</p>\n<ul>\n<li><strong>함수형 언어</strong>는 함수의 재귀적 정의에 기초한 계산 모델을 사용합니다. 그들은 1930년대에 알론조 교회가 개발한 형식적인 계산 모델인 람다 미적분학에서 영감을 얻었습니다. 본질적으로 프로그램은 입력에서 출력까지의 함수로 간주되며, 정제 과정을 통해 단순한 함수로 정의됩니다. 이 범주의 언어에는 Lisp, ML 및 Haskell이 포함됩니다.</li>\n<li><strong>데이터 흐름 언어</strong>는 원시 함수 노드 간의 정보 흐름(토큰)으로 계산을 모델링합니다. 노드는 입력 토큰의 도착에 의해 트리거되며 동시에 작동할 수 있습니다. Id와 Val은 데이터 흐름 언어의 예입니다. Val의 후손인 Sisal은 함수형 언어로 더 자주 묘사됩니다.</li>\n<li><strong>논리 또는 제약 기반 언어</strong>는 술어 논리로부터 영감을 받았습니다. 그들은 논리 규칙 목록을 통한 목표 지향 검색을 사용하여 특정 특정 관계를 만족시키는 값을 찾기 위한 시도로 계산을 모델링합니다. 프롤로그는 가장 잘 알려진 논리 언어입니다. 이 용어는 SQL 데이터베이스 언어, XSLT 스크립트 언어, 그리고 엑셀과 그 이전 버전들과 같은 스프레드시트의 프로그래밍 가능한 측면에도 적용됩니다.</li>\n<li><strong>폰 노이만어</strong>는 아마도 가장 친숙하고 널리 사용되는 언어일 것입니다. 여기에는 포트란, 에이다, C 및 기본적인 연산 수단이 변수의 수정인 다른 모든 항목이 포함됩니다. 함수형 언어가 값을 갖는 표현에 기반을 두는 반면, 폰 노이만 언어는 기억의 값을 바꾸는 side effect<em>를</em> 통해 후속 계산에 영향을 미치는 문장(특히 할당)에 기초합니다.</li>\n<li><strong>객체 지향 언어</strong>는 그 기원이 시물라 67에 있다. 대부분은 폰 노이만어와 밀접한 관련이 있지만, 훨씬 더 구조적이고 분산적인 기억과 계산 모델을 가지고 있습니다. 객체 지향 언어들은 단일 메모리 상에서 단일 프로세서의 연산으로 연산을 하기보다는 반의존 객체들 간의 상호작용으로 계산을 하며, 각각은 그 상태를 관리하기 위한 자체 내부 상태와 서브루틴을 모두 가지고 있습니다. 스몰토크는 객체 지향 언어 중 가장 순수하며, C++와 자바가 가장 널리 사용됩니다. 객체 지향 함수형 언어(CLOS [Kee89]와 OCaml로 가장 잘 알려져 있음)를 고안하는 것도 가능하지만 명령적인 경향이 강하게 있습니다.</li>\n<li><strong>스크립트 언어</strong>는 몇몇 주변 문맥에서 추출한 구성 요소를 조정하거나 “접착”하는 것에 중점을 두는 것으로 구별됩니다. csh와 bash는 작업 제어(쉘) 프로그램의 입력 언어입니다; PHP와 자바스크립트는 주로 동적 웹 콘텐츠 생성을 위한 것입니다; Lua는 컴퓨터 게임을 제어하기 위해 널리 사용됩니다. 펄, 파이썬, 루비를 포함한 다른 언어들은 더 범용적입니다. 대부분은 신속한 프로토타이핑을 강조하며, 실행 속도보다 표현이 쉬운 편입니다.</li>\n</ul>\n<p>어떤 사람은 병렬 언어가 별개의 어족을 형성할 것이라고 생각할 수도 있지만, 동시 실행과 순차 실행의 구분은 위의 분류와는 거의 무관합니다. 대부분의 병렬 프로그램들은 포트란이나 C와 같은 순차적 언어와 함께 특별한 라이브러리 패키지나 컴파일러를 사용하여 작성됩니다. 자바, C#, 에이다를 포함하여 널리 사용되는 몇몇 언어에는 명시적으로 동시 기능이 있습니다. 연구자들은 여기에 언급된 각 어족들의 동시성을 조사하고 있습니다.</p>\n<p>어족 간의 대조를 보여주는 간단한 예로서, 이 장의 시작 부분에 소개된 최대공약수(GCD) 문제를 고려해봅시다. 이 문제에 대한 폰 노이만, 함수형, 논리형 프로그래밍의 선택은 코드의 모양뿐만 아니라 프로그래머의 사고방식에도 영향을 미칩니다. 폰 노이만 알고리즘 버전은 매우 중요합니다.</p>\n<p><strong>GCD function in C: 폰노이만</strong></p>\n<p>a와 b의 gcd를 계산하려면 a와 b가 같은지 확인하십시오. 만약 그렇다면, 그것들 중 하나를 인쇄하고 멈추세요. 그렇지 않으면 큰 수를 두 수의 차이로 교체하고 반복합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">!=</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">></span> b<span class=\"token punctuation\">)</span> a <span class=\"token operator\">=</span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span> b <span class=\"token operator\">=</span> b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>GCD function in OCaml: 함수형</strong></p>\n<p>a와 b의 gcd는</p>\n<ol>\n<li>a와 b가 같을 때 a</li>\n<li>a > b일 때 b와 a - b의 gcd</li>\n<li>b > a일 때 a와 b - a의 gcd로 정의된다.</li>\n</ol>\n<p>주어진 숫자의 gcd를 계산하려면 이 정의가 끝날 때까지 확장 및 단순화하십시오.</p>\n<div class=\"gatsby-highlight\" data-language=\"ocaml\"><pre class=\"language-ocaml\"><code class=\"language-ocaml\"><span class=\"token keyword\">let</span> recgcdab<span class=\"token operator\">=</span> \n\t<span class=\"token keyword\">if</span> a <span class=\"token operator\">=</span> b <span class=\"token keyword\">then</span> a\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> a <span class=\"token operator\">></span> b <span class=\"token keyword\">then</span> gcd b <span class=\"token punctuation\">(</span>a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">)</span> \n\t\t<span class=\"token keyword\">else</span> gcd a <span class=\"token punctuation\">(</span>b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>GCD rules in Prolog: 논리</strong></p>\n<p>논리 언어에서 프로그래머는 시스템이 원하는 값을 찾을 수 있는 일련의 공리와 증명 규칙을 지정합니다.</p>\n<p>다음과 같은 경우 명제 gcd(a, b, g)는 참이다.\n(1) a, b, g는 모두 동일하다;\n(2) a는 b보다 크고 c는 a - b이고 gcd(c, b, g)가 참인 숫자 c가 존재한다.\n(3) a는 b보다 작으며 c는 b - a이고 gcd(c, a, g)가 참인 숫자 c가 존재한다.</p>\n<p>주어진 숫자의 gcd를 계산하기 위해서, 이 규칙들이 gcd(a, b, g)가 참이라는 것을 증명할 수 있는 숫자 g를 찾아라.</p>\n<div class=\"gatsby-highlight\" data-language=\"prolog\"><pre class=\"language-prolog\"><code class=\"language-prolog\"><span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span>B<span class=\"token punctuation\">,</span>G<span class=\"token punctuation\">)</span> <span class=\"token operator\">:-</span> A <span class=\"token operator\">=</span> B<span class=\"token punctuation\">,</span> G <span class=\"token operator\">=</span> A<span class=\"token operator\">.</span>\n<span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span>B<span class=\"token punctuation\">,</span>G<span class=\"token punctuation\">)</span> <span class=\"token operator\">:-</span> A <span class=\"token operator\">></span> B<span class=\"token punctuation\">,</span> C <span class=\"token operator\">is</span> A<span class=\"token operator\">-</span>B<span class=\"token punctuation\">,</span> <span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>C<span class=\"token punctuation\">,</span>B<span class=\"token punctuation\">,</span>G<span class=\"token punctuation\">)</span><span class=\"token operator\">.</span>\n<span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span>B<span class=\"token punctuation\">,</span>G<span class=\"token punctuation\">)</span> <span class=\"token operator\">:-</span> B <span class=\"token operator\">></span> A<span class=\"token punctuation\">,</span> C <span class=\"token operator\">is</span> B<span class=\"token operator\">-</span>A<span class=\"token punctuation\">,</span> <span class=\"token function\">gcd</span><span class=\"token punctuation\">(</span>C<span class=\"token punctuation\">,</span>A<span class=\"token punctuation\">,</span>G<span class=\"token punctuation\">)</span><span class=\"token operator\">.</span></code></pre></div>\n<p>:-를 if, 쉼표를 and로 읽으면 더 이해하기 쉽습니다.</p>\n<p>어족 간의 구분이 명확하지 않다는 점을 강조하고 싶습니다. 예를 들어, 폰 노이만과 객체 지향 언어 사이의 구분은 종종 매우 모호하며, 많은 스크립트 언어도 객체 지향적입니다. 대부분의 함수 언어들과 논리 언어들은 일부 명령적 특징들을 포함하고 있으며, 최근의 몇몇 명령적 언어들은 함수적 특징들을 추가하였습니다.(c++, Java의 람다 등)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADq0lEQVQ4y2WU244jNRCG87Y8BBLPgMQ1t1xwAdwDCyu0gHbYw+wp2WQymWQm6YP75G4f2na7P9Sdnd0dsGTZKpXLVX/99S+yLCNNU4QQVFVFVVfUTUN+Skivb6h3tzjnkOs9XSaY1hhHxnGE8XzO98k+jiyklNR1TQhhNsYY8cZikhxT1HSnHNMb1pfPsYcEpRVtUfIhAvfrPuiCz9YYI12SU29uCB/8rY8YZ1iXO4K2ZPsDx9Md/xze03uHDeFBlospo+naa0P+ds0YAsYP/HW5wzmP98P5t2GkV5ouS5leFEqinMWEQIjxU8kfs3OeNs3n4D4MiLrD+UCrDGWjsM7PfqqqaHXHvszQzs4Q7asSqTXT48WtECwPB25ERlrfMcRIIiQ3x5Ky6siyhkZ2fPPDK0TZ4lqFC4GtOKF9j/KOYYgM4znLxUEInm42HOt6Nrg4kuYVXvcY7fBuIDlmfP9oxc1ekMuGTAp+X79gme5prT5n3hgaoT6VXMmWbZqTNxIpC8LgMC6wOeRcLA90Ss1+k62zOT+9eUzW1jM8XW9nKhWnhkVzbOh1j+0tl7v9vCdcmByNZXkU1LbikJbcZIqs/pNd8tXUI5pqg/cF1inqRs3VPKCNnhrjA6aqef/rY8Y4kDaG1fWa3158x3VS4YeMk/iFYRho2kt6V2NMhTHNuSl7sUZ7g3GOvOvmwN73hHDuquwkL1/nrG8vKao91tb0LmN/d2S7y3De0XVnak24L5QpaZ1GO42yEt87anHCao3ViqJ6hzZblJJcvs6QsqF3JXnekKZ65qqzPdU+xTaKxRBH+jAx3s2EJUR01VLsEkwtGYk07Zo4OOIAZVmSFX/gvGS1EtRNT3FIWP58MWO/UFajvDmXtn3Do8PfOO/pnJxhmGY8eE9xfaKVmiSV5LmgrhVStnOQ22drrh6/JI7x3JR+cLw/bPj60bd88eOXrC5e0zlFmTdz95pOzbjGIXJ1lfDkyS2tlAyxxxnL6MKn0Zu6NanJ88MblsUWozSmaul7S3MqCUOg0jWFyXl6ITieulk0nIuEEGGA26rkphT/V5v7Je6W9HYi8qQ0Fh0dE9ZJ0tApQ5JJklRxe9fRSkdt1EzuOeD4mUhOe8pYNQJxWOJUTQwOpw3Bmo8ftkbPmQsxnfGBJv4nILjeoE1HU6dUfYuyHad3bzm+XRHGyLPyGZvu6qP+TWx+oIcPBPZeyqepGRwrsaWYJ2AkSyq07bnutuR9/qCqzxX7X9cM+6roLND1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"programming-languages_label.png\"\n        title=\"programming-languages_label.png\"\n        src=\"/static/dae46a1cf4550e54aa89179f48ff0540/37523/programming-languages_label.png\"\n        srcset=\"/static/dae46a1cf4550e54aa89179f48ff0540/e9ff0/programming-languages_label.png 180w,\n/static/dae46a1cf4550e54aa89179f48ff0540/f21e7/programming-languages_label.png 360w,\n/static/dae46a1cf4550e54aa89179f48ff0540/37523/programming-languages_label.png 720w,\n/static/dae46a1cf4550e54aa89179f48ff0540/302a4/programming-languages_label.png 1080w,\n/static/dae46a1cf4550e54aa89179f48ff0540/07a9c/programming-languages_label.png 1440w,\n/static/dae46a1cf4550e54aa89179f48ff0540/2a614/programming-languages_label.png 5000w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"13-why-study-programming-languages\" style=\"position:relative;\"><a href=\"#13-why-study-programming-languages\" aria-label=\"13 why study programming languages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3 Why Study Programming Languages?</h2>\n<p>프로그래밍 언어는 일반적인 컴퓨터 과학 커리큘럼의 중심입니다. 한 가지 이상의 고급 언어에 익숙해진 학생들은 일반적으로 다른 언어에 대해 배우 싶어 합니다. 언어에 대해 배우는 것은 흥미롭고 또한 실용적입니다.</p>\n<p>한 가지 예로, 언어 설계와 구현에 대한 올바른 이해는 주어진 작업에 가장 적합한 언어를 선택하는 데 도움이 될 수 있습니다. 대부분의 언어들은 특정 문제에 더 좋습니다. 시스템 프로그래밍을 위해 C, C++, 또는 C# 중 어떤 것을 선택해야 하는가? 과학적 계산을 위한 포트란이나 C? 웹 기반 응용 프로그램용 PHP 또는 Ruby? 임베디드 시스템의 경우 Ada 또는 C? 그래픽 사용자 인터페이스를 위한 Visual Basic 또는 Java? 이 책은 당신이 그러한 결정을 할 수 있도록 도와줄 것입니다.</p>\n<p>마찬가지로, 이 책은 새로운 언어를 배우는 것을 더 쉽게 만들어 줄 것입니다. 많은 언어들이 밀접하게 연관되어 있습니다. Java 및 C#는 C++를 이미 알고 있는 경우, Common Lisp, ML을 이미 알고 있는 경우 Haskell, 그리고 더 중요한 것은 모든 프로그래밍 언어의 기초가 되는 기본 개념이 있다는 것입니다. 이러한 개념의 대부분은 유형, 제어(반복, 선택, 재귀, 비결정성, 동시성), 추상화 및 명명 등의 이 책의 주제입니다. 이러한 개념의 관점에서 생각하는 것은 새로운 언어의 구문(형태)과 의미를 아무것도 모를 때에 비해 더 쉽게 동화시킵니다.</p>\n<p>어떤 언어를 배우든 해당 언어의 설계와 구현에 사용된 결정을 이해하면 언어를 더 잘 사용하는 데 도움이 됩니다. 이 책이 도움이 될 것입니다.</p>\n<p><strong>불분명한 특징을 이해합니다.</strong> 일반적인 C++ 프로그래머는 유니언, 다중 상속, 가변 인수 수 또는 .* 연산자를 거의 사용하지 않습니다. 새로운 언어의 설명을 단순화하듯이, 설명서에서 세부 사항을 찾아볼 때 기본 개념을 이해하면 이러한 기능을 쉽게 이해할 수 있습니다.</p>\n<p><strong>구현 비용에 대한 지식을 바탕으로 사물을 표현하는 대안적인 방법 중 하나를 선택하세요.</strong> 예를 들어, C++에서 프로그래머는 초기화 비용을 최소화하기 위해 필요하지 않은 임시 변수를 피하고 가능하면 복사 생성자를 사용해야 합니다. Java에서는 명시적 쓰레드 작성 대신 Executor 오브젝트를 사용할 수 있습니다. 특정(부실) 컴파일러의 경우 가장 빠른 코드를 얻기 위해 특수 프로그래밍 숙어 배열 트래버설을 위한 포인터; x*x <em>대신 x**2</em>를 채택해야 할 수 있습니다. 어떤 언어에서든, 그들은 대체적인 기준 구현들 간의 트레이드오프를 평가할 수 있어야 합니다. 예를 들어, 비트 집합 카디널리티와 같은 기능에 대한 계산과 테이블 조회 사이의 트레이드오프를 평가할 수 있어야 합니다.</p>\n<p><strong>디버거, 어셈블러, 링커 및 관련 도구를 유용하게 사용합시다</strong>. 일반적으로 고급 언어 프로그래머는 구현 세부 사항을 신경 쓸 필요가 없습니다. 그러나 이러한 세부 사항에 대한 이해가 사실상 필수적인 경우가 있습니다. 누군가가 비트를 엿볼 의향이 있다면 끈질긴 버그나 특이한 시스템 구축 문제는 극적으로 다루기 쉬울 수 있습니다.</p>\n<p><strong>해당 기능이 없는 언어로 유용한 기능을 시뮬레이션합니다.</strong> 구형 언어에는 매우 유용한 특정 기능이 누락되어 있지만, 의도적인(강제적이지 않은) 프로그래밍 스타일을 따라 에뮬레이트할 수 있습니다. 포트란의 오래된 방언에서는 최신 제어 구조에 익숙한 프로그래머가 주석과 자체 규율을 사용하여 잘 구성된 코드를 작성할 수 있습니다. 마찬가지로, 추상화 기능이 부족한 언어에서 주석과 명명 규칙은 모듈 구조를 이미테이션하는 데 도움이 될 수 있으며, Clu, C#, Python 및 Ruby의 매우 유용한 반복자(섹션 6.5.3에서 연구할)는 서브루틴과 정적 변수를 사용하여 모방할 수 있습니다.</p>\n<p><strong>어디에서든 언어 기술을 더 잘 활용할 수 있습니다.</strong> 대부분의 프로그래머는 전통적인 프로그래밍 언어를 설계하거나 구현하지 않지만, 대부분은 다른 프로그래밍 작업을 위해 언어 기술이 필요합니다. 일반적인 개인용 컴퓨터에는 워드 프로세싱, 스프레드시트, 프리젠테이션, 래스터 및 벡터 그래픽, 음악, 비디오, 데이터베이스 및 기타 다양한 응용 프로그램 도메인을 포함하는 수십 개의 구조화된 형식의 파일이 포함되어 있습니다. 웹 콘텐츠는 XSLT 스크립트 언어로 쉽게 조작할 수 있도록 설계된 텍스트 기반 형식인 XML로 점점 더 많이 표현되고 있습니다(섹션 C 14.3.5에서 설명). 따라서 구조화된 데이터를 구문 분석, 분석, 생성, 최적화 및 기타 조작하는 코드는 거의 모든 정교한 프로그램에서 찾을 수 있으며, 이 모든 코드는 언어 기술을 기반으로 합니다. 이 기술을 잘 이해하고 있는 프로그래머는 잘 구조화되고 유지 관리가 가능한 도구를 작성할 수 있는 더 나은 위치에 있습니다.</p>\n<p>마찬가지로 시작 구성 파일, 명령줄 인수, 입력 명령 또는 기본 제공 확장 언어를 통해 대부분의 도구 자체를 사용자 정의할 수 있습니다(14장에서 자세히 설명). 내 홈 디렉토리에는 250개 이상의 개별 구성(“기본 설정”) 파일이 있습니다. 이맥스 텍스트 편집기를 위한 나의 개인 구성 파일은 1200줄 이상의 리스프 코드로 구성되어 있습니다. 오늘날 거의 모든 고급 프로그램을 사용하는 사용자는 구성 또는 확장 언어를 잘 사용해야 합니다. 이러한 프로그램의 설계자는 기존의 확장 언어를 채택(및 적응)하거나 자신만의 새로운 표기법을 발명해야 합니다. 언어 이론을 잘 이해하고 있는 프로그래머는 현재 사용자의 요구를 충족하고 향후 개발을 용이하게 하는 우아하고 잘 구성된 표기법을 설계하기에 더 나은 위치에 있을 것입니다.</p>\n<p>마지막으로, 이 책은 당신이 그렇게 마음이 내키면 언어 설계나 구현에 대해 더 깊이 공부할 수 있도록 도와줄 것입니다. 또한 사용자가 관심을 가질 경우 운영 체제 및 아키텍처와 언어의 상호 작용을 이해할 수 있습니다.</p>\n<h3 id=\"check-your-understanding\" style=\"position:relative;\"><a href=\"#check-your-understanding\" aria-label=\"check your understanding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Check Your Understanding</strong></h3>\n<aside>\n💡\n<ol>\n<li>기계어와 어셈블리어의 차이점은 무엇입니까?</li>\n<li>고급 언어는 어떤 면에서 어셈블리어를 개선합니까? 어셈블러에서 프로그래밍하는 것이 여전히 가능한 상황들이 있나요?</li>\n<li>왜 이렇게 프로그래밍 언어가 많아요?</li>\n<li>프로그래밍 언어를 성공적으로 만드는 것은 무엇입니까?</li>\n<li>다음 범주에서 각각 세 가지 언어를 말하세요: von Neumann, 기능적, 객체 지향. 논리 언어 두 개를 말하시오. 널리 사용되는 동시 언어 두 개를 말하시오.</li>\n<li>선언적 언어와 명령적 언어를 구분하는 것은 무엇입니까?</li>\n<li>어떤 단체가 에이다의 개발을 주도했나요?</li>\n<li>일반적으로 최초의 고급 프로그래밍 언어는 무엇입니까?</li>\n<li>최초의 함수형 언어는 무엇이었습니까?</li>\n<li>그림 1.1에서 병렬 언어가 별도의 어족으로 나열되지 않는 이유는 무엇입니까?</li>\n</ol>\n</aside>\n<h2 id=\"14-compilation-and-interpretation\" style=\"position:relative;\"><a href=\"#14-compilation-and-interpretation\" aria-label=\"14 compilation and interpretation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.4 Compilation and Interpretation</h2>\n<p>가장 높은 수준의 추상화에서 고급 언어로 된 프로그램의 컴파일 및 실행은 다음과 같습니다.</p>\n<p><strong>Example 1.7 Pure compliation</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 553px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8UlEQVQoz42S6QqDQAyE9/0f0D+CIt7ireutKZM24tXSQHCPZMh8rqJPbNt2+pZlSZZlURRF5Ps+r8Mw3Gskr6G+CY7jSHVdU1EUlKYpZ9u2J8GnUMeNFK3rSsuy8Lrrul0I5/M83+p/TogGTNb3PU8XBAHZts3WcaZbTVrr/wWnaaKqqmgYBrYJdoZhkOM4jAHTHq3fBI+AJcUa1hBByvRA8dQjqZ7AolFEmqZh69fzb6FgxXXdHT5YoQl70zRJ7mE9jmNuAmNwBBLP8/guSZL3hHhvKIBNJMQAH+L4IXh7EMJbzLKM71AjWLDP83zn+gJdbb3r4k36VwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/3449e7057a1043c804c91e8f023574e3/74cfa/Untitled.png\"\n        srcset=\"/static/3449e7057a1043c804c91e8f023574e3/e9ff0/Untitled.png 180w,\n/static/3449e7057a1043c804c91e8f023574e3/f21e7/Untitled.png 360w,\n/static/3449e7057a1043c804c91e8f023574e3/74cfa/Untitled.png 553w\"\n        sizes=\"(max-width: 553px) 100vw, 553px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>컴파일러는 고급 소스 프로그램을 동등한 대상 프로그램(일반적으로 기계어로)으로 변환한 다음 사라집니다. 나중에 사용자가 운영 체제에 대상 프로그램을 실행하도록 지시합니다. 컴파일러는 컴파일 중에 제어 위치에 있으며, 대상 프로그램은 자체 실행 중에 제어 위치에 있습니다. 컴파일러 자체는 기계어 프로그램이며, 아마도 다른 고급 프로그램을 컴파일하여 만든 것으로 보입니다. 운영 체제가 이해하는 형식으로 파일에 기록할 때 기계 언어는 일반적으로 객체 코드로 알려져 있습니다.</p>\n<p>고급 언어의 대체 구현 스타일을 <em>interpretation</em>이라고 합니다.</p>\n<p><strong>Example 1.8 Pure interpretation</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 598px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 15.555555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAe0lEQVQI122NywrFIAwF/f8vVKEbRS3dCAq+7bkk0HIXDQxO4iERzjkYYxitNaivtaK1hpwze0oJMUaGvJTC3PfNzDmZvTcEDUjWWm94jIHrumCt5SC5lBJKKT5I/5Slg/Se54njOBBCgMBfee+Z3vt7lZwWPD35M/uqH9Le5tTD2y/2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/c61d5c920c6039472d2ae68ca59206b9/0c69d/Untitled1.png\"\n        srcset=\"/static/c61d5c920c6039472d2ae68ca59206b9/e9ff0/Untitled1.png 180w,\n/static/c61d5c920c6039472d2ae68ca59206b9/f21e7/Untitled1.png 360w,\n/static/c61d5c920c6039472d2ae68ca59206b9/0c69d/Untitled1.png 598w\"\n        sizes=\"(max-width: 598px) 100vw, 598px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>컴파일러와 달리 인터프리터는 응용 프로그램을 실행하기 위해 주변에 있습니다. 실제로 인터프리터는 실행 중 제어의 중심입니다. 실제로 인터프리터는 “머신 언어”가 고급 프로그래밍 언어인 가상 시스템을 구현합니다. 통역사는 그 언어로 된 문장을 어느 정도 한 번에 읽고 진행하면서 실행합니다.</p>\n<p>일반적으로 interpretation은 컴파일보다 유연성이 더 높고 진단(오류 메시지)이 더 우수합니다. 소스 코드가 직접 실행되기 때문에 인터프리터는 우수한 소스 수준 디버거를 포함할 수 있습니다. 또한 변수의 크기와 종류, 심지어는 어떤 변수를 지칭하는 이름과 같은 프로그램의 기본 특성이 입력 데이터에 따라 달라질 수 있는 언어도 다룰 수 있습니다. 예를 들어, Lisp 및 Prolog에서 프로그램은 자신의 새로운 스크립트를 작성하고 즉시 실행할 수 있습니다. (여러 스크립트 언어도 이러한 기능을 제공합니다.) 실행 시간이 될 때까지 프로그램 구현에 대한 결정을 지연하는 것은 late binding으로 알려져 있습니다; 우리는 3.1절에서 더 길게 논의할 것입니다.</p>\n<p>반면, 컴파일은 일반적으로 더 나은 성능을 제공합니다. 일반적으로 컴파일 시간에 내린 결정은 런타임에 내릴 필요가 없는 결정입니다. 예를 들어, 컴파일러가 변수 x가 항상 위치 49378에 있음을 보장할 수 있다면 원본 프로그램이 x를 참조할 때마다 이 위치에 액세스하는 기계어 명령을 생성할 수 있습니다. (final version of a) 프로그램은 한 번만 컴파일되지만 일반적으로 여러 번 실행되므로, 특히 인터프리터가 루프의 모든 반복에서 불필요한 작업을 수행하는 경우 상당한 절감 효과를 얻을 수 있습니다.</p>\n<p>컴파일과 해석의 개념적 차이는 분명하지만, 대부분의 언어 구현은 두 가지 모두를 포함합니다. 일반적으로 다음과 같습니다.</p>\n<p><strong>Example 1.9 Mixing complication and interpretation</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyElEQVQoz5VS2wqFMAzb//+iT4o673fFeySBHUTkgIOyrmvTNJsBgHmekSQJrLXwfR9VVTGM8zxlX5Y5jgPLsoB7XdeYpgnbtmFd11/SF1DT972Ki6KA53liSMaME/jO9M2ekxiCOWuaBsMwCOgO9m89GxgGu67TuEEQIM9zacizA933XT5loc+dBN6aCZDjlWUpI1iWZQKktnEco21bSRJFkR4vDENNMo6jcui7GvPWhYxZTC1dIZMJlqapfgNJ8J5M+ZC8p2QXvGMiKLlayPIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/62bc275ead7b18dba589460c70d48725/37523/Untitled2.png\"\n        srcset=\"/static/62bc275ead7b18dba589460c70d48725/e9ff0/Untitled2.png 180w,\n/static/62bc275ead7b18dba589460c70d48725/f21e7/Untitled2.png 360w,\n/static/62bc275ead7b18dba589460c70d48725/37523/Untitled2.png 720w,\n/static/62bc275ead7b18dba589460c70d48725/f8067/Untitled2.png 726w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>우리는 일반적으로 초기 번역기가 단순할 때 언어가”interpreted”되어 있다고 말합니다. 번역기가 복잡하면 우리는 언어가 “컴파일”되어 있다고 말합니다. “단순”과 “복합”은 주관적인 용어이고 컴파일러(복합 번역기)가 복잡한 가상 머신(인터프리터)에 의해 실행되는 코드를 생성하는 것이 가능하기 때문에 구별이 헷갈릴 수 있습니다. 이는 실제로 Java에서는 기본적으로 발생합니다. 우리는 번역자가 (일부 “기계적” 변환을 수행하는 대신) 철저하게 분석하고 중간 프로그램이 소스와 강하게 유사하지 않을 경우 언어를 컴파일한다고 여전히 말합니다. 이러한 두 가지 특성, 즉 철저한 분석과 사소한 변환은 컴파일의 특징입니다.</p>\n<aside>\n💡 **DESIGN & IMPLEMENTATION**\n<p>특정 언어(예: Smalltalk 및 Python)는 대부분의 semantic error checking이 런타임에 수행되어야 하므로 “interpreted languages”라고도 합니다. 다른 특정 언어(예: 포트란 및 C)는 거의 모든 semantic error checking이 정적으로 수행될 수 있기 때문에 “compiled languages”라고도 합니다. 이 용어는 정확하지 않습니다: C 및 Portran용 인터프리터는 쉽게 빌드될 수 있으며 컴파일러는 코드를 생성하여 가장 광범위한 동적 semantic error checking도 수행할 수 있습니다. 그렇긴 하지만, 언어 디자인은 “compilability”에 깊은 영향을 미칩니다.</p>\n</aside>\n<p>실제로 다음과 같은 광범위한 구현 전략을 볼 수 있습니다.</p>\n<p><strong>Example 1.10 Preprocessing</strong></p>\n<p>대부분의 <em>interpreted languages</em>는 주석과 공백을 제거하고 키워드, 식별자, 숫자 및 기호와 같은 토큰으로 문자를 그룹화하는 초기 번역기(전처리기)를 사용합니다. 번역기는 매크로 어셈블러 스타일로 약어를 확장할 수도 있습니다. 마지막으로, 루프 및 서브루틴과 같은 상위 수준의 구문 구조를 식별할 수 있습니다. 소스의 구조를 반영하지만 보다 효율적으로 해석할 수 있는 중간 형태를 만드는 것이 목표입니다.</p>\n<p>Basic의 초기 구현에서는 실제로 프로그램의 성능을 향상시키기 위해 프로그램에서 주석을 제거할 것을 제안했습니다. 이러한 구현은 순전히 인터프리터였습니다. 프로그램의 특정 부분을 실행할 때마다 코멘트를 다시 읽고 무시했습니다. 그들은 초기 번역가가 없었습니다.</p>\n<p><strong>Example 1.11 Library routines and linking</strong></p>\n<p>전형적인 포트란 구현은 순수 컴파일에 가깝습니다. 컴파일러는 포트란 소스를 기계어로 번역합니다. 그러나 일반적으로 원본 프로그램의 일부가 아닌 서브루틴 라이브러리의 존재에 의존합니다. 예로는 수학 함수(sin, cos, log 등)와 I/O가 있습니다. 컴파일러는 링커라는 별도의 프로그램에 의존하여 적절한 라이브러리 루틴을 최종 프로그램에 병합합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 451px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.22222222222221%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABeklEQVQ4y42Uia6CQAxF+f8PxBiDiqDI4oYLuEDNaV7JiGBekwam07m093bw5M/atv14Xi4X2W63kqapJEkii8VCVquVrl+vV5drbuaJY+6Ga1VVyf1+/4r3i/gAdDdvt5ucz2f1uq61wt1up8BlWWrcPtAv4gsQgOPxKE3TKABtLpdLmU6nUhSFxh+PR5fzVWGfh+fzKafTSa7Xq1YCSBzHEkWR7Pf7Lo73ecS9Ic7YoArATSCAqIhWLT5kHgdJwmmRtRtD0TzP5XA4dB+DFtxyeSdXK8yyTObzuTo82YgEQaDcGX++7ysoAGEYymw2k81mI+v1WnOJjbY8NDa4a1Aw2HKfVFcg2sUZcATBjEcqcvnsRPkFyGggCE67qA0FgKMyVRJ3Qb0hhV1AEwbi4Qx+GW6rnhGD138BcsBmjmoAAsBuEms+9NHy2BwOmd2iX2e8sQ3Ipz14Y0QYD9aTyUSvI3HWiGOKj7bs/iRMFN5pERHsavJkzxXlDZ2P3xR/isQPAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/677a823eb7fac1b10ca2f0917f34c03f/38070/Untitled3.png\"\n        srcset=\"/static/677a823eb7fac1b10ca2f0917f34c03f/e9ff0/Untitled3.png 180w,\n/static/677a823eb7fac1b10ca2f0917f34c03f/f21e7/Untitled3.png 360w,\n/static/677a823eb7fac1b10ca2f0917f34c03f/38070/Untitled3.png 451w\"\n        sizes=\"(max-width: 451px) 100vw, 451px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>어떤 의미에서는 라이브러리 루틴을 하드웨어 명령어 집합의 확장으로 생각할 수 있습니다. 컴파일러는 하드웨어와 라이브러리의 기능을 모두 포함하는 가상 시스템의 코드를 생성하는 것으로 간주할 수 있습니다.</p>\n<p>문자 그대로, 포트란 루틴에서 포맷된 출력에 대한 해석을 찾을 수 있습니다. 포트란은 열의 출력 정렬, 부동소수점 숫자에 대한 유효 자릿수 및 과학적 표기법 유형, 선행 0의 포함/억제 등을 제어하는 형식 문을 사용할 수 있습니다. 프로그램은 자체 형식을 즉시 계산할 수 있습니다. 출력 라이브러리 루틴에는 형식 인터프리터가 포함됩니다. 비슷한 인터프리터는 C와 그 후손들의 프린트프 루틴에서 찾을 수 있습니다.</p>\n<p><strong>Example 1.12 Post-compilation assembly</strong></p>\n<p>많은 컴파일러가 기계어 대신 어셈블리어를 생성합니다. 어셈블리 언어는 사람들이 읽기 쉽기 때문에 디버깅을 용이하게 하고, 컴파일러를 새로운 운영 체제 릴리스에서 강제할 수 있는 기계어 파일 형식의 변경으로부터 격리시킵니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 243px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 145%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACsklEQVRIx42W6U4qQRCFef/XIfwgJAYMIASVVVndZVERBWUVqJuvcos0PYNSSae7ZmqqTy19eiLyX7bbrc7L5VKOEbO32STiG9zc3EihUJCLiws5Pz+X6+trubq6Ur1YLEoul5NarSZnZ2dyf38fcBpwuFgsZDwey3A4lPf3d/n4+JCHhwfVX19fpdPpyOfnp+rf399Bhy50H74JH359fR0M3fUR+c2RCchAe0xOdyFPJhN5e3vTUGzgCHSpVEoymYyi5Jm9ZxO+cUNXh3d3d1qM5+dneXp6ksfHR133ej3p9/vy8vIig8FAB894h43ZkVfWinA0GqkzX6bTqRqDqNvt6gfValWRrVargL0VK4IBVfRlNpvpczar1+vaJuVyWXU6wRdaiBRENpuNtFotDZV8gIhh+SQCyxUIbG12BgiEe0XBiBAJzwY6OWw0GtJsNnUdZuN2wFFtQ/iMv9pm14cIoR+SSqWiKMPObqCxXaP5fK7HjqTTc+SHVrEqg5LqG2LsrOJ7jW0Khcnn81rR09NTJYJ0Oq3Vbbfb+i4aje7ex2IxzX2oQwZhr9dr+fn50ZmBgBpk2EAWRAI6OsAPe89h2EAIH6dhAohQtvlNSAUtc1SVTeG8+j1mzU6+stmsFolnfh/S4DuE5Imm5aV/AsgRAzbhlLApum/HJhRNEfLSmMIVPob+OVJQPpW+vLzUawCq88VYPULV7By6QiFAjSEHnxyCCHIIYxsQKtuYd5y6fIgznBgHurrxIbasIRfmvSrT+T5jo5Oz29tbHUQTZmN0dvSdQs4OXVKBO+XQhe1KqVTakcOft57rzFgafiNU8sIMQnJG0kGKblerHc9QcsCQBj45OdHehASSyaRuwp8DeiKR0JmbMB6P735dAteoGzJrdna50sgDVJAHBAFh+Dn8BwWDq49QHqOCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/d61808ce2b75e7285d06ff227665577d/8aea6/Untitled4.png\"\n        srcset=\"/static/d61808ce2b75e7285d06ff227665577d/e9ff0/Untitled4.png 180w,\n/static/d61808ce2b75e7285d06ff227665577d/8aea6/Untitled4.png 243w\"\n        sizes=\"(max-width: 243px) 100vw, 243px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Example 1.13 The C preprocessor</strong></p>\n<p>C용 컴파일러(및 Unix에서 실행되는 다른 여러 언어의 경우)는 주석을 제거하고 매크로를 확장하는 전처리로 시작합니다. 또한 프리 프로세서는 코드 자체의 일부를 삭제하도록 지시할 수 있으며, 동일한 소스에서 프로그램의 여러 버전을 작성할 수 있는 조건부 컴파일 기능을 제공합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 238px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 145.55555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdCAYAAACqhkzFAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC0klEQVRIx42WCWvyYAzH+/2/jwMRYQ4GUzfFYyoec+o85715H3n5BVKe9u02A8H2aZL+k/yT6omIXK9XVaTf78t0OpXFYiGz2UxWq5V8f3/LZDKR5XLp63g81vOwvxc+qNfrks/n5fHxUbVarUqpVJL7+3vJZrNyd3cnLy8vEo/Hpd1uq8/lcgkGNLHDsIAUJ+R4PMpvPgGEKI6m5/NZjSjBfr/3neyZIQuk/BMqV2q1mgyHwz/tiKUID4eDOvR6PdWPjw/VTqcjo9FIHh4eJJ1O63W321V1bTm3Unjb7VbK5bIG/Pz8VMXAukq36ebX15fM53O/y9hhwy/MeH19VWAenYIarjSbTXl+ftZUc7mcGjcaDb2vVCpSKBQ0qCsEB7FHdC5cAfV6vdaUCU6XyQDkg8FAEZ1Op4APwOCmNgUnEBDg/f1da0RtcCSA3XNtyhm2+MBd46TnoqJeVjeUmoEUBxDyjDPUtXUp5Rn3fhN4GCZ0WIyTntwgjBoluYmHRKaG1IhUcLRGUEMoQzNImfQ3m42fNuzgDFvu/ZQzmYwOP0hYCMlkUp6enqRYLOpCgCaQm6XBy3jOeSwWUx98sf9vOfwkoLQ6u3MLkSNHz10IUcsB0tLJ8BKxIGZ/83KANtTx5uUAJUAB000JgFJs6kqtuLaJcW2ZZ8vG2+12uhzoMsam1lk4yGKAxNzTURtBs2VqmHGA6XKA7WHhrW9vb0ojFgSLgc7S+SiSgxRQns1sWOggaHjOd4WAoAJAVN1td2pTKHqr1dKtYwvUloGlbtcgce24hpv4B3gI40mTmpnSKBoBQl4A4rAN9/Y59WnzF3UIGt5/UZRR2liw34JCGcryk50bw3MP2IkMP2igE8NP7YyXnNEslE5jZ8gDCC0gG5glwKDzTWHo+acAT6FPKpWSRCKh53wFWQ62qSNThu3MLOqi4J5fzmgCvAWt+22xgP8ANOGiR2I/LegAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/22ad75a949c6003f0910b57e0f04f186/5ea4d/Untitled5.png\"\n        srcset=\"/static/22ad75a949c6003f0910b57e0f04f186/e9ff0/Untitled5.png 180w,\n/static/22ad75a949c6003f0910b57e0f04f186/5ea4d/Untitled5.png 238w\"\n        sizes=\"(max-width: 238px) 100vw, 238px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Example 1.14 Source-to-source</strong></p>\n<p>놀랍게도 많은 수의 컴파일러가 일부 고급 번역 언어(일반적으로 C 또는 일부 단순화된 입력 언어 버전)로 출력을 생성합니다. 이러한 소스 간 번역은 연구 언어와 언어 개발 초기 단계에서 특히 일반적입니다. 한 가지 유명한 예는 AT&#x26;T의 C++용 오리지널 컴파일러입니다. C++ 소스 프로그램의 구문과 의미론에 대한 완전한 분석을 수행했으며 프로그래머가 프로그램을 실행하기 전에 볼 수 있는 모든 오류 메시지를 생성했습니다. 사실, 프로그래머들은 일반적으로 C 컴파일러가 막후에서 사용되고 있다는 것을 알지 못했습니다. C++ 컴파일러는 오류 메시지를 생성하지 않고 2차 컴파일을 통과하는 C 코드를 생성하지 않는 한 C 컴파일러를 호출하지 않았습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 354px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAB2klEQVQ4y42U567DMAiF/f5v1qp/2kpd6kj3XumeXH1IRI6bXAUJ2TEGw+EEJ558v19dX6+XDIdDGY/HslwuZbVayWQykel0que73S513xdnBlPk/X7LfD6XwWCga7/fl263K+12W/ebzSYV0A/s/EBZLyLn81nyJPR1oeF6vUocx3I6nVQfj4fU63Ut/Xa7qc2USv7N8HA4yGw2k/V6rQFGo5FqFEVaKvgBAZiiYAreqQz9gABvFxCCgl2z2ZRaraaPfT6fxE5Qkvgp2T4ul0vSWZRMaQAP4czebGSK+k1NZWgvs4IdjWDlERz3+31yhoJ1yBDUSQEBR5pTRBwvVatV5RhYscI/Sm+1Whqs1+vpvtPp6B3swEDmRnbD1z2fT2U+4IIZ++PxqCWCG3vWxWKhztzhLnawNAoBTeGScc4j/U/JIag4k4l1kYwrlYpykew4ozwyhuhhY1I8xAGFi1yGJkYXMGOlPLNzdr/f84lNZnYBJzKhSTQNpVEE9IkNxrnEpkEENSUgwBOIUimTM2ychVMnyTBv0vhQWOaFpo1/6P81JvAua4T5SWSOLzukHIZBo9GQUqmkZEbL5bJiSdf9X+9nYocBwRKi4oRSLrrdbrUJYJc1Cwn4B/liB6XcKMG9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/b3c93354c34a6db667390b1585dc0d18/8f50f/Untitled6.png\"\n        srcset=\"/static/b3c93354c34a6db667390b1585dc0d18/e9ff0/Untitled6.png 180w,\n/static/b3c93354c34a6db667390b1585dc0d18/8f50f/Untitled6.png 354w\"\n        sizes=\"(max-width: 354px) 100vw, 354px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>때때로 C++ 컴파일러가 컴파일된 높은 수준의 출력을 생성했기 때문에 전처리기라고 불리는 소리를 듣기도 했습니다. 컴파일러는 소스를 “이해”하려고 하지만 프리프로세서는 그렇지 않습니다. 프리프로세서는 간단한 패턴 일치를 기반으로 변환을 수행하며, 후속 변환 단계를 통해 실행될 때 오류 메시지를 생성하는 출력을 생성할 수 있습니다.</p>\n<p><strong>Example 1.15 Bootstrapping</strong></p>\n<p>컴퓨터 기술 에서 <strong>부트스트래핑</strong> 이라는 용어 는 동일한 언어로 코딩할 수 있는 언어 컴파일러를 나타냅니다. (예를 들어, C 컴파일러는 이제 C 언어로 작성되었습니다. 기본 컴파일러가 작성되면 반복적으로 개선할 수 있으므로 부트스트랩으로 언어를 끌어올릴 수 있습니다.)</p>\n<p>많은 초기 파스칼 컴파일러들은 니클라우스 워스가 배포한 도구들을 기반으로 만들어졌습니다. 여기에는 다음이 포함됩니다.</p>\n<ul>\n<li>파스칼로 작성된 파스칼 컴파일러로, 현대 자바 컴파일러의 바이트코드와 유사한 스택 기반 언어인 P-code로 출력을 생성합니다.</li>\n<li>P 코드로 변환된 컴파일러</li>\n<li>파스칼로 작성된 P코드 인터프리터</li>\n</ul>\n<p>Pascal을 로컬 컴퓨터에서 설정하고 실행하려면 도구 세트의 사용자는 P 코드 인터프리터를 로컬에서 사용할 수 있는 언어로 직접 번역하기만 하면 됩니다. 이 번역은 어려운 일이 아니었습니다. 인터프리터는 작았습니다. 컴파일러의 P-코드 버전을 P-코드 인터프리터 위에 실행하면 임의 파스칼 프로그램을 P-코드로 컴파일하여 인터프리터에서 실행할 수 있습니다. 더 빠른 구현을 위해 P코드(좀 더 어려운 작업)를 생성하는 대신 파스칼 컴파일러의 파스칼 버전을 수정하여 로컬로 사용 가능한 다양한 어셈블리 또는 기계어를 생성할 수 있습니다. 그런 다음 이 컴파일러를 부트스트랩(bootstrap, 자체 실행)하여 컴파일러의 기계 코드 버전을 생성할 수 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 525px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABU0lEQVQ4y52TCa+CMBCE+///IF54AHIZEQRUDtmXb5MawGdMbLK0pZvZ2ZnWiIjUdS2Hw0GOx6PEcSxhGMp6vZbr9cqxDMMgn4Y9s7PhUxSFrFYrDc/zFNxxHMnzXJqmUeCyLCfxeDzewBTQbvq+lyRJZLfbKWjbtq/k/4KubrfbW46ZtwAbCzZua8zCrrMsk67rJrkGZlVVKRAz+l0ul1drc3AkuN/v2nKapsqUNf8AN+jHAt32+722DSitkwSobQ9NmckLgkCiKFJ5MJAz8o1lttlsxHVdBQOUAjDgzAJSnD0AGAgogBhIV7A3sIMFyXM32ZNkB+2T/3w+tTBBYQoyKGa+3a+xKQBZvQCHtdXT/jOfrsU45hcYIxmn00k7oNDkYn8bY2DYbLdb1Q9zCPTElJ8A0RZTFouFPlVMWS6Xcj6ffwPETd/3lSUzQQHM4aX8AXwb7qs3D7qAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/ef39c17b3240952d1881c47b4a7f1daf/52211/Untitled7.png\"\n        srcset=\"/static/ef39c17b3240952d1881c47b4a7f1daf/e9ff0/Untitled7.png 180w,\n/static/ef39c17b3240952d1881c47b4a7f1daf/f21e7/Untitled7.png 360w,\n/static/ef39c17b3240952d1881c47b4a7f1daf/52211/Untitled7.png 525w\"\n        sizes=\"(max-width: 525px) 100vw, 525px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>좀 더 일반적인 맥락에서 새로운 프로그래밍 언어를 위한 최초의 컴파일러 중 하나를 만들고 있다고 가정해 보겠습니다. 대상 시스템에 C 컴파일러가 있다고 가정하면 새 프로그래밍 언어의 동일한 하위 집합에 대한 컴파일러를 C의 단순한 하위 집합에 작성하는 것으로 시작할 수 있습니다. 컴파일러가 작동하면 C 코드를 새 언어로 직접 번역한 다음 컴파일러 자체를 통해 새 소스를 실행할 수 있습니다. 그 후 컴파일러를 반복적으로 확장하여 더 큰 서브셋을 수용할 수 있습니다.</p>\n<aside>\n💡 DESIGN & IMPLEMENTATION\n<p><strong>파스칼의 초기 성공</strong>\nP코드 기반의 파스칼의 구현과 부트스트래핑의 사용은 파스칼이 학계에서 놀라운 성공을 거둔 큰 원인이 됩니다.\n1970년대에 오늘날의 x86, Linux 및 Windows처럼 컴퓨터 환경을 지배한 하드웨어 플랫폼이나 운영 체제는 없었습니다.8 Wirth의 툴킷은 Pascal을 일주일 정도 만에 거의 모든 플랫폼에서 실행할 수 있게 만들었습니다. 이것은 시스템 이식성에 있어서 최초의 큰 성공들 중 하나였습니다.</p>\n</aside>\n<p>새로운 프로그래밍 언어를 다시 부트스트랩하고 확장 언어를 사용하여 더 큰 하위 집합을 구현합니다. 이러한 종류의 “셀프 호스팅” 구현은 실제로 매우 일반적입니다.</p>\n<p><strong>Example 1.16 Compiling interpreted</strong></p>\n<p>때때로 많은 late binding을 허용하는 언어(예: 리스프, 프롤로그, 스몰토크)용 컴파일러를 찾기도 하며 전통적으로 해석됩니다. 이러한 컴파일러는 일반적으로 인터프리터의 많은 작업을 수행하거나 대신 작동하는 라이브러리로 호출하는 코드를 생성하기 위해 준비되어야 합니다. 그러나 중요한 경우 컴파일러는 런타임까지 최종 결정되지 않을 결정에 대해 합리적인 가정을 하는 코드를 생성할 수 있습니다. 이러한 가정이 유효하면 코드는 매우 빠르게 실행됩니다. 가정이 올바르지 않으면 동적 검사가 불일치를 발견하고 인터프리터로 돌아갑니다.</p>\n<p><strong>Example 1.17 Dynamic and just-in-time compilation</strong></p>\n<p>경우에 따라 프로그래밍 시스템은 컴파일이 완료될 때까지 컴파일을 의도적으로 지연시킬 수 있습니다.\n가능한 마지막 순간이에요 새로운 변환을 위해 컴파일러를 즉시 호출하는 언어 구현(예: Lisp 또는 Prolog)에서 한 가지 예가 발생합니다.\n소스를 기계어로 만들거나 특정 입력 세트의 코드를 최적화합니다. 또 다른 예는 Java 구현에서 볼 수 있습니다. Java 언어 정의는 Java byte code로 알려진 기계 독립적인 중간 형식을 정의합니다. 바이트코드는 Java 프로그램 배포를 위한 표준 형식입니다. 인터넷을 통해 프로그램을 쉽게 전송한 다음 모든 플랫폼에서 실행할 수 있습니다. 최초의 자바 구현체는 바이트 코드 인터프리터에 기반을 두었지만, 현대의 구현체들은 프로그램의 각 실행 직전에 바이트코드를 기계 언어로 변환하는 just-in-time 컴파일러를 통해 훨씬 더 나은 성능을 얻습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 594px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABbElEQVQ4y3WTja6CMAyF9/7vZ4JBUFEBQRD/UBHpzdekZKK3SbPRdWc9p8WJiAzDIP76fr9ls9nIdruV5XIpu91OY5xbjuX7MVbnH07tdDrJ4/H4ik+B/ftuWmHTNOpFUYxVsifGAz7Y6/WS6/Wq60eFltD3vZRlKZfLRRaLhVKdz+e6b9tWDoeD5pg9n0+V5H6/j7EvyiTxKherqhorsJjl4MT3+/34jbtfTSERimmaSl3Xcjwepes61ZMqsyyTJEnUV6uVrsiDNO6XsHQUvbgMGHsDpOo8zxVovV4rUBzHSp2H3LRr6GE0efF8PivY7XbTdWow8c35YGgECIBhGCqV2WwmURRpUzizjmLkBUGg8bHL/nDiVMSraAc1aEAT2gD4uRSADFb5x2D7Olo3AbbBtj/lPxsHm1mzPwIAZhAKCM0Z4iM480kOWlIp1TP0MPL74AChEWjDipNEhzkDiFmj28yZdRtgn4EB/gH2evANTX5RmwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/c56f7a55cff4c7b5ef158ef8858948b7/5fd3e/Untitled8.png\"\n        srcset=\"/static/c56f7a55cff4c7b5ef158ef8858948b7/e9ff0/Untitled8.png 180w,\n/static/c56f7a55cff4c7b5ef158ef8858948b7/f21e7/Untitled8.png 360w,\n/static/c56f7a55cff4c7b5ef158ef8858948b7/5fd3e/Untitled8.png 594w\"\n        sizes=\"(max-width: 594px) 100vw, 594px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>마찬가지로 C#도 즉시 번역을 위한 것입니다. 주 C# 컴파일러는 CIL(Common Intermediate Language)을 생성하고, CIL은 실행 직전에 기계어로 변환됩니다. CIL은 의도적으로 언어와 독립적이므로 다양한 프런트 엔드 컴파일러가 생성하는 코드에 사용할 수 있습니다. Java 및 C# 구현에 대해 섹션 16.1에서 자세히 살펴보겠습니다.</p>\n<p><strong>Example 1.18 Microcode (firmware)</strong></p>\n<p>일부 기계(특히 1980년대 중반 이전에 설계된 기계)에서 어셈블리 수준의 명령어 집합은 실제로 하드웨어에서 구현되지 않고 인터프리터에서 실행됩니다. 인터프리터는 읽기 전용 메모리에 저장되고 하드웨어에 의해 실행되는 마이크로코드(또는 펌웨어)라는 낮은 수준의 명령어로 작성됩니다. 마이크로코드 및 마이크로프로그래밍은 섹션 C 5.4.1에서 더 자세히 검토됩니다.</p>\n<hr>\n<p>이러한 예들 중 일부가 분명히 나타내듯이 컴파일러가 반드시 고급 프로그래밍 언어를 기계어로 변환하는 것은 아닙니다. 실제로 일부 컴파일러는 즉시 프로그램으로 생각되지 않을 수 있는 입력을 수용합니다. 예를 들어, TEX와 같은 텍스트 형식 지정기는 높은 수준의 문서 설명을 레이저 프린터 또는 포토타이프세터용 명령어로 컴파일합니다. 데이터베이스 시스템의 쿼리 언어 프로세서는 SQL과 같은 언어를 파일의 기본 작업으로 변환합니다. 논리 수준의 회로 사양을 컴퓨터 칩용 사진 마스크로 변환하는 컴파일러도 있습니다. 비록 이 책의 초점은 명령형 프로그래밍 언어에 있지만, “컴파일”이라는 용어는 입력의 의미에 대한 완전한 분석과 함께 하나의 중요하지 않은 언어에서 다른 언어로 자동 번역될 때마다 적용됩니다.</p>\n<h2 id=\"15-programming-environments\" style=\"position:relative;\"><a href=\"#15-programming-environments\" aria-label=\"15 programming environments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5 Programming Environments</h2>\n<p>컴파일러와 인터프리터는 따로 존재하지 않습니다. 프로그래머들은 많은 다른 도구들의 도움을 받습니다. 어셈블러, 디버거, 프리프로세서, 링커 등이 앞서 언급되었습니다. 에디터는 모든 프로그래머에게 친숙합니다. 프로그래머가 객체가 사용되는 지점이 주어지면 객체가 정의되는 지점을 찾을 수 있는 상호 참조 기능을 통해 증강될 수 있습니다. 예쁜 프린터는 서식 규칙을 적용하는 데 도움이 됩니다. 스타일 체커는 컴파일러가 시행하는 것보다 더 엄격한 구문 또는 의미 규칙을 적용합니다(탐색 1.14 참조). 구성 관리 도구는 대규모 소프트웨어 시스템에서 별도로 컴파일된 모듈 간의 의존성을 추적하는 데 도움이 됩니다. 텍스트뿐 아니라 바이너리로 저장될 수 있는 중간 언어에 대해서도 열람 도구가 있습니다. 프로파일러 및 기타 성능 분석 도구는 종종 디버거와 함께 작동하여 계산 시간의 대부분을 소비하는 프로그램의 조각을 식별하는 데 도움이 됩니다. 오래된 프로그래밍 환경에서는 다음 위치에서 도구를 개별적으로 실행할 수 있습니다.\n사용자의 명시적 요청입니다. 예를 들어 실행 중인 프로그램이 “bus error”(잘못된 주소) 메시지와 함께 비정상적으로 종료되는 경우, 사용자는 운영 체제에서 덤프된 “core” 파일을 검사하기 위해 디버거를 호출하도록 선택할 수 있습니다. 그런 다음 중단점을 설정하고 추적 등을 활성화한 다음 디버거의 제어 하에 프로그램을 다시 실행하여 프로그램 버그를 식별할 수 있습니다. 버그가 발견되면 사용자는 편집기를 호출하여 적절한 변경을 수행합니다. 그런 다음 구성 관리자의 도움을 받아 수정된 프로그램을 다시 컴파일합니다.</p>\n<p>현대 환경은 보다 통합된 도구를 제공합니다. IDE(Integrated Development Environment)에서 잘못된 주소 오류가 발생하면 오류가 발생한 소스 코드의 줄이 강조 표시된 새 창이 사용자 화면에 나타날 수 있습니다. 그런 다음 디버거를 명시적으로 호출하지 않고 이 창에서 중단점과 추적을 설정할 수 있습니다. 편집기를 명시적으로 호출하지 않고 소스를 변경할 수 있습니다. 사용자가 변경한 후 프로그램을 다시 실행하도록 요청할 경우 컴파일러나 구성 관리자를 명시적으로 호출하지 않고 새 버전을 빌드할 수 있습니다. IDE용 편집기는 언어 구문에 대한 지식을 통합하여 모든 표준 제어 구조에 대한 템플릿을 제공하고 입력된 구문을 검사할 수 있습니다. 내부적으로 IDE는 프로그램의 소스 코드와 객체 코드뿐만 아니라 부분적으로 컴파일된 내부 표현도 유지할 수 있습니다. 소스를 편집하면 내부 표현이 자동으로 업데이트됩니다(종종 소스의 많은 부분을 재배치하지 않고). 프로그램에 대한 구조적 변경사항이 내부 표현에서 먼저 구현된 후 소스에 자동으로 반영되는 경우도 있습니다. IDE는 스몰토크의 기본이며, 그래픽 환경에서 언어를 구분하는 것은 거의 불가능하며 1980년대부터 Common Lisp에 일상적으로 사용되어 왔습니다. 그래픽 인터페이스가 보편화되면서 통합 환경은 많은 언어와 시스템의 명령줄 도구를 대체했습니다. 널리 사용되는 오픈 소스 IDE에는 Eclipse와 NetBeans가 있습니다. 상용 시스템에는 Microsoft의 Visual Studio 환경과 Apple의 XCode 환경이 포함됩니다. 통합의 외형의 많은 부분은 이맥과 같은 정교한 편집기에서도 달성될 수 있습니다.</p>\n<aside>\n💡 CHECK YOUR UNDERSTANDING\n<ol>\n<li>compilation과 interpretation의 차이를 설명하세요. 두 가지 접근법의 비교적인 장점과 단점은 무엇입니까?</li>\n<li>Java는 컴파일 또는 인터프리터(또는 둘 다)입니까?</li>\n<li>컴파일러와 전처리의 차이점은 무엇입니까?</li>\n<li>오리지널 AT&#x26;T C++ 회사에서 사용한 중간 형태는 무엇입니까?</li>\n<li>P-코드가 무엇입니까?</li>\n<li>부트스트래핑이 뭐죠?</li>\n<li>JIT 컴파일러란 무엇입니까?</li>\n<li>프로그램이 “즉시” 자신의 새로운 조각을 쓸 수 있는 두 언어를 말하시오.</li>\n<li>범용 프로세서에서 실행할 고급 프로그램을 준비하는 것이 목적이 아닌 세 가지 “전통적이지 않은” 컴파일러를 간략하게 설명합니다.</li>\n<li>대규모 프로그래밍 환경에서 컴파일러의 작업을 일반적으로 지원하는 6가지 도구를 나열합니다.</li>\n<li>IDE(통합 개발 환경)가 명령줄 도구 모음과 어떻게 다른지 설명합니다.</li>\n</ol>\n</aside>\n<h2 id=\"16-an-overview-of-compilation\" style=\"position:relative;\"><a href=\"#16-an-overview-of-compilation\" aria-label=\"16 an overview of compilation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6 An Overview of Compilation</h2>\n<p>컴파일러는 가장 잘 연구된 컴퓨터 프로그램 중 하나입니다. 우리는 책의 나머지 부분, 특히 2, 4, 15, 17장에서 그것들을 반복적으로 고려할 것입니다. 이 섹션의 나머지 부분에서는 소개 개요를 제공합니다.</p>\n<p><strong>Example 1.19 Phases of compilation and interpretation</strong></p>\n<p>일반적인 컴파일러에서 컴파일은 그림 1.3에서와 같이 잘 정의된 일련의 단계를 통해 진행됩니다. 각 단계는 이후 단계에 대한 사용 정보를 검색하거나 프로그램을 후속 단계에 더 유용한 형태로 변환합니다. 처음 몇 단계는 (시맨틱 분석을 통해) 소스 프로그램의 의미를 파악하는 역할을 합니다. 컴파일러의 프런트 엔드로 불리기도 합니다. 마지막 몇 단계는 동등한 대상 프로그램을 구성하는 역할을 합니다. 컴파일러의 백엔드라고도 합니다.</p>\n<p>인터프리터(그림 1.4)는 컴파일러의 프런트 엔드 구조를 공유하지만 중간 형식을 기계어로 번역하지 않고 직접 “실행”합니다. 일반적으로 실행은 구문 트리를 순회(워크)하는 상호 재귀 서브루틴 집합의 형태를 취하며 노드를 프로그램 순서로 “실행”합니다. 많은 컴파일러 및 인터프리터 단계가 원본 및/또는 대상 언어에 대한 공식적인 설명에서 자동으로 생성될 수 있습니다.</p>\n<p>때때로 일련의 패스로 묘사되는 컴파일을 들을 수 있습니다. 패스는 나머지 컴파일과 관련하여 직렬화되는 페이즈 또는 페이즈 세트입니다. 패스는 이전 페이즈가 완료될 때까지 시작되지 않으며 이후 페이즈가 시작되기 전에 완료됩니다. 원하는 경우 패스를 별도의 프로그램으로 작성하여 파일에서 입력을 읽고 출력을 파일에 기록할 수 있습니다. 컴파일러는 일반적으로 패스로 나뉘어 프런트 엔드가 공유될 수 있습니다.</p>\n<p><strong>Figure 1.3 Phases of compilation.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABf0lEQVQoz12Ti66CQAxE+f+/IyIQgspDhfjgLaiovTlNSvSSNLt2u9OZ6eqIiHw+H7ler1LXtUbXdfJ8PmUYBt2T45yoqkoul4vm+77XdZommecZKHEAM1Autm2rRbfbTZqm0SiKQo7Ho66Hw0HyPFfw8/ksj8dDgSHwA/h+v5XR/X7XjuwphFFZlgoIGLHf7zVvgDSnGbkFkI8uxhAwAtYUw8oiyzJliHSkmhqIOACRhCGAHHLA3lhst1txXVfiOBbP82S9XitjzsymxUNYBEGgxWEYym63U4l0RA6XyG02G0nTVFcCwNPppPKphRBqndfrJQQf/iHFpmxTBXC1WkkUReL7voYB4il+22BVMkygDrMkSXS154BP+AY7vLM9vsIehUi2WSxD4dAuUYyXFCLHmMDKps0Zzcx37sB0AeQHBYDac4A1OYoZhsllSNTQiDrusv8BtAFgOAzGcVTJ+IjxNGK1ZwNT+1dRa3NYALnMIVLo9P0+v/f/c98rQ/kDvo+QhddLg60AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/65911a8cff6177a859c2b4fe421f16c6/37523/Untitled9.png\"\n        srcset=\"/static/65911a8cff6177a859c2b4fe421f16c6/e9ff0/Untitled9.png 180w,\n/static/65911a8cff6177a859c2b4fe421f16c6/f21e7/Untitled9.png 360w,\n/static/65911a8cff6177a859c2b4fe421f16c6/37523/Untitled9.png 720w,\n/static/65911a8cff6177a859c2b4fe421f16c6/ea7fb/Untitled9.png 788w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>단계는 오른쪽에 나열되고 양식은 다음과 같습니다.\n정보는 단계 간에 전달됩니다(왼쪽). 기호 테이블은 컴파일 내내 식별자에 대한 정보를 위한 저장소로 사용됩니다.</p>\n<p><strong>Figure 1.4 Phases of interpretation.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABXUlEQVQoz3WS666CQAyEff+nkx8EgigQiIAXkJs3kJqvJyVqcjYZdre7TGfaXb1eLzkcDnI8HhWn00nGcZRpmuTxeEjf9zIMwzLb+nq9yvP5lNvtpvfhmedZVnw4AJAALrVtqwkul4tkWSZlWUpRFJKmqc6ccwZIYmPFhwyorKpKFTZNo6Ts9/u9Is9zhe25j9JP5YhShQB7kNzvd12j4Hw+f5ECU9h1nZ6jnvtRFEld138KTSUBiEwhe34Ow1B/2O12st1uJUkSJcMNewgRpZZRYPVgRjoXUEDd4jiW9XotruuK7/viOI54nqeJINxsNpqc2ish2ckcBIEqwRYK7QLkdNAahhNrIEmpJbFFofwzKDY/UFOeyC+I4wZXJGTos0GudQ2L7AFkxO2cutEASoADA6X6ImRBwPA5sAaxPQ+rNyCOUtbYXyzbwoY9o9+4JcAqoCG8S7qNM+oI4RuvFEyWM0lWSAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/079d6b1707c0dc20d39f1a2f345f1df2/37523/Untitled10.png\"\n        srcset=\"/static/079d6b1707c0dc20d39f1a2f345f1df2/e9ff0/Untitled10.png 180w,\n/static/079d6b1707c0dc20d39f1a2f345f1df2/f21e7/Untitled10.png 360w,\n/static/079d6b1707c0dc20d39f1a2f345f1df2/37523/Untitled10.png 720w,\n/static/079d6b1707c0dc20d39f1a2f345f1df2/6c2f2/Untitled10.png 767w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>프런트 엔드는 컴파일러의 프런트 엔드와 본질적으로 동일합니다. 마지막 단계에서는 일반적으로 구문 트리를 실행하는 상호 재귀 서브루틴 집합을 사용하여 중간 양식을 “실행”합니다.</p>\n<p>둘 이상의 머신(대상 언어)에 대해 백엔드를 둘 이상의 소스 언어에 대해 컴파일러가 공유할 수 있습니다. 일부 구현에서는 프런트 엔드와 백 엔드가 언어 및 기계 독립 코드 개선을 담당하는 “미들 엔드”에 의해 분리될 수 있습니다. 1980년대 중후반 메모리 크기가 급격하게 증가하기 전에 컴파일러는 다음과 같습니다.\n또한 메모리 사용을 최소화하기 위해 패스로 나뉘기도 했습니다. 각 패스가 완료되면 다음 패스는 코드 공간을 재사용할 수 있습니다.</p>\n<h3 id=\"161-lexical-and-syntax-analysis\" style=\"position:relative;\"><a href=\"#161-lexical-and-syntax-analysis\" aria-label=\"161 lexical and syntax analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6.1 Lexical and Syntax Analysis</h3>\n<p><strong>Example 1.20 GCD program in C</strong></p>\n<p>다음 C 코드를 고려해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">getint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token function\">getint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> j<span class=\"token punctuation\">)</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> j<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span> j <span class=\"token operator\">=</span> j <span class=\"token operator\">-</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">putint</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Example 1.21 GCD program tokens</strong></p>\n<p>스캔 및 파싱은 프로그램의 의미에 관계없이 프로그램의 구조를 인식하는 역할을 합니다. 스캐너는 문자(‘i’, ‘n’, ‘t’, ‘m’, ‘a’, ‘i’, ‘n’)를 읽습니다.\n’(’, ’) 등) 및 토큰으로 그룹화합니다. 토큰은 프로그램의 최소 의미 단위입니다. 이 예에서 토큰은 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">int     main   (      )    {      int   i    =    getint (    )   ,    j    =   \ngetint  (      )      ;    while  (     i    !=   j      )    {   if   (    i  \nj       )      i      =    i      -     j    ;    else   j    =   j    -    i\n;     \t}    \t putint (    i      )     ;    }</code></pre></div>\n<p>스캔은 어휘 분석(lexical analysis)이라고도 합니다. 스캐너의 주된 목적은 입력 크기를 줄이고(토큰보다 더 많은 문자 수) 공백과 같은 외부 문자를 제거하여 파서의 작업을 단순화하는 것입니다. 또한 스캐너는 일반적으로 주석을 제거하고 토큰에 줄과 열 번호를 태그하여 이후 단계에서 양호한 진단을 쉽게 생성할 수 있도록 합니다. 토큰 대신 문자를 입력으로 가져가도록 파서를 설계할 수 있습니다. 스캐너를 사용하는 대신, 결과는 어색하고 느릴 것입니다.</p>\n<p><strong>Example 1.22 Context-free grammar and parsing</strong></p>\n<p>구문 분석은 토큰을 구성 요소 측면에서 상위 수준의 구문 분석 구조(문, 표현식, 서브루틴 등)를 나타내는 구문 분석 트리로 구성합니다. 각 구조는 트리의 노드이며 구성 요소는 하위 항목입니다. 트리의 루트는 단순히 “프로그램”입니다; 왼쪽에서 오른쪽으로의 잎은 스캐너에서 받은 토큰입니다. 전체적으로, 트리는 토큰이 유효한 프로그램을 만들기 위해 어떻게 서로 결합되는지를 보여줍니다. 이 구조는 문맥 없는 문법이라고 알려진 잠재적으로 재귀적인 규칙 집합에 의존합니다. 각 규칙에는 왼쪽에 구성품 이름이 있고 오른쪽에 확장 가능한 화살표 기호(→)가 있습니다. 예를 들어 C에서 while loop는 키워드로 구성되며 부모 크기의 부울 표현식과 문은 다음과 같습니다.</p>\n<p>iteration-statement → while ( expression ) statement</p>\n<p>이 문은 종종 중괄호로 묶인 리스트입니다.</p>\n<p>statement → compound-statement\ncompound-statement → { block-item-list opt }</p>\n<p>where</p>\n<p>block-item-list opt → block-item-list</p>\n<p>or</p>\n<p>block-item-list opt → ϵ</p>\n<p>and</p>\n<p>block-item-list → block-item\nblock-item-list → block-item-list block-item\nblock-item → declaration\nblock-item → statement</p>\n<p>여기서 ϵ는 빈 문자열을 나타내며, block-item-list opt를 간단히 삭제할 수 있음을 나타냅니다. 물론 프로그램의 전체 구조를 설명하기 위해서는 더 많은 문법 규칙이 필요합니다.</p>\n<p><strong>Example 1.23 GCD program parse tree</strong></p>\n<p>context-free grammar는 언어의 구문을 정의한다고 하며, 구문 분석이라고 합니다. C에 대해 가능한 문법(사실 무한대로)이 많이 있습니다. 위의 부분은 공식 언어 정의에 포함된 샘플 문법 [Int99]에서 가져온 것입니다. GCD 프로그램의 전체 구문 분석 트리(여기에 표시되지 않은 전체 문법에 기초함)가 그림 1.5에 나와 있습니다. 나무의 크기가 위압적으로 보일 수 있지만, 이 시점에서 나무의 세부 사항은 특별히 중요하지 않습니다. 중요한 것은 입니다.</p>\n<ol>\n<li>각각의 분기점은 하나의 문법 규칙의 적용을 나타냅니다</li>\n<li>결과적인 복잡성은 입력 프로그램의 그것보다 문법을 더 반영합니다. 대량 생산의 대부분은 (a) 블록 항목 목록 및 블록 항목 목록과 같은 인위적인 “구성체”를 사용하여 임의 목록을 생성하는 선택에서 비롯됩니다.</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABdklEQVQ4y4XUh47DMAwD0Pz/h3bvvX14Bhi4aYsT4EZ1JIoS7XSv16tYbOgvl8uy3W7LL0tsa10LEHs+nxUI4HQ6rf75fC7X67Wu2+1WvuVVwHYT0Ol0Kvv9viwWi+ofDoey2+0qkP3RaFTm83kFHXb1wfDxeFSQAIzH4zKbzep/DC1sASv+bUyV4f1+L8fjsYLkPxbY8TebTblcLtVfr9dltVpVcASG8+wECgCgTYHayTMFxFniMNaJGHst2w4L7MJSYAISpE1A/ABHGM8wrYB+WgDBACxFjEGbGUHMu2HhXuUYho4JISaTSS+GURDI+29n8U2UdgP9CGMvYFTlYxnm2myPS89wuClQgvawBcTsAwTeKp73IdYDEkNCbkLYmZNkJ0HLbk9uDUDrTZSAOWtJAGiPb465RQzDjEYHSCj48+pJUNGTEAq1ajJFsNc6YMWBvokSUGDaswTlyiUhp4E4mMbPB6QbSo8NBgIlYIplWv3vM/YHC6nj38hmj/oAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"캡처.PNG\"\n        title=\"캡처.PNG\"\n        src=\"/static/67032afd3ae57a0cf30aaa1637ffccfc/37523/capture.png\"\n        srcset=\"/static/67032afd3ae57a0cf30aaa1637ffccfc/e9ff0/capture.png 180w,\n/static/67032afd3ae57a0cf30aaa1637ffccfc/f21e7/capture.png 360w,\n/static/67032afd3ae57a0cf30aaa1637ffccfc/37523/capture.png 720w,\n/static/67032afd3ae57a0cf30aaa1637ffccfc/302a4/capture.png 1080w,\n/static/67032afd3ae57a0cf30aaa1637ffccfc/ee515/capture.png 1269w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABZElEQVQ4y3XTiY7CMAwE0Pz/byJxlJajHOXO6kW4G1CJZJo4zsz4IL1er2zdbrd8uVzKnu/bwv/9PRwOH76U3+t4PBb7tWqQ2BOw2+3y8/kc75IfF4vFopj9/X4vJvDxeEyC8W+329w0TR6G4R/QBWWYBNRpCuy6roDXKkPder3O1+v1gyxREZdt2+bz+VzYGRJ+RM5WqHa3XC5z3/djyqWGHMGkMR7v9/ux4FISE0scYoCUEyCTKFECcjqdioPS1WpVQDyYzWZ5Pp8XEkAeMESAvLVHgBTG2GVpuAQoGMlmsylBFFDNprqvB+PYYPaYqQkDANSeUmSaQ/nUrH40JSTHYKunvRT4ETkDpjgAf81qokZgpCVlZ2AUIZQFwPrOWRaIpRzjkzgFxDBTIEXgAKNuvtFtMVQTgYQ5F8C6DsAxY6RMDQE5xz8mmicuBj+67JzqGnCoYQyxNKKm9QJSdxw4U8M/jzlCaZZ81LgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"캡처.PNG\"\n        title=\"캡처.PNG\"\n        src=\"/static/e125fb92459fdb91eaa80b24790776b8/37523/capture1.png\"\n        srcset=\"/static/e125fb92459fdb91eaa80b24790776b8/e9ff0/capture1.png 180w,\n/static/e125fb92459fdb91eaa80b24790776b8/f21e7/capture1.png 360w,\n/static/e125fb92459fdb91eaa80b24790776b8/37523/capture1.png 720w,\n/static/e125fb92459fdb91eaa80b24790776b8/302a4/capture1.png 1080w,\n/static/e125fb92459fdb91eaa80b24790776b8/7960f/capture1.png 1274w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>Figure 1.5 Parse tree for the GCD program</strong></p>\n<p>기호 ϵ는 빈 문자열을 나타냅니다. 점선은 공간을 절약하기 위해 생략된 일대일 교체 체인을 나타냅니다. 인접한 숫자는 생략된 노드의 수를 나타냅니다. 트리의 세부 사항은 현재 장에서 중요하지 않지만, 자세한 내용은 문맥 없는 문법의 계층 구조에 (훨씬 더 간단한) 소스 코드를 맞추어야 하는 것에서 비롯됩니다.</p>\n<p>길이 및 (b) 동일한 인공 할당-표현, 가법 표현, 곱셈-표현 등을 사용하여 산술 표현식의 우선 순위와 연관성을 포착합니다. 우리는 파싱이 완료되면 이 복잡성의 많은 부분이 폐기될 수 있다는 것을 다음 하위 섹션에서 볼 것입니다.\n스캔과 구문 분석 과정에서 컴파일러 또는 인터프리터는 프로그램의 모든 토큰이 잘 형성되었는지, 그리고 다음 순서인지 확인합니다.\n토큰은 문맥 없는 문법에 의해 정의된 구문을 따릅니다. 잘못된 형식의 토큰(예: C의 123abc 또는 $@foo)은 스캐너에서 오류 메시지를 생성해야 합니다. 구문적으로 잘못된 토큰 시퀀스(예: A = X Y Z in C)는 구문 분석기에서 오류 메시지를 발생시킵니다.</p>\n<h3 id=\"162-semantic-analysis-and-intermediate-code-generation\" style=\"position:relative;\"><a href=\"#162-semantic-analysis-and-intermediate-code-generation\" aria-label=\"162 semantic analysis and intermediate code generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6.2 Semantic Analysis and Intermediate Code Generation</h3>\n<p>의미 분석은 프로그램에서 의미를 발견하는 것입니다. 무엇보다도, 의미 분석기는 동일한 식별자가 여러 번 발생하더라도 동일한 프로그램 엔티티를 참조하도록 되어 있는 경우를 인식하고, 그 용도가 일관되도록 보장합니다. 또한 대부분의 언어에서 식별자와 표현식의 유형을 추적하여 일관된 사용을 확인하고 컴파일러의 백엔드에서 코드 생성을 안내합니다. 시맨틱 분석기는 작업을 지원하기 위해 일반적으로 각 식별자를 알려진 정보에 매핑하는 기호 테이블 데이터 구조를 구축하고 유지합니다. 무엇보다도 이 정보에는 식별자의 유형, 내부 구조(있는 경우) 및 범위(이 정보가 유효한 프로그램 부분)가 포함됩니다. 기호 테이블을 사용하여 의미 분석기는 컨텍스트 프리 문법과 구문 분석 트리의 계층 구조로 캡처되지 않는 다양한 규칙을 적용합니다. 예를 들어 C에서는 다음을 확인합니다.</p>\n<ul>\n<li>모든 식별자는 사용 전에 선언됩니다.</li>\n<li>식별자가 부적절한 컨텍스트(정수를 서브루틴으로 호출하고, 정수에 문자열을 추가하고, 잘못된 형식의 필드를 참조)에 사용되지 않습니다.</li>\n</ul>\n<p>(구조 등)입니다.</p>\n<ul>\n<li>서브루틴 호출은 올바른 인수 수와 유형을 제공합니다.</li>\n<li>스위치 문 암의 레이블은 별개의 상수입니다.</li>\n<li>반환 유형이 아닌 함수는 명시적으로 값을 반환합니다.</li>\n</ul>\n<p>많은 프런트 엔드에서 의미 분석기의 작업은 구문 분석기가 문법 규칙 내에서 특정 지점에 도달했음을 인식할 때 파서에 의해 호출되는 의미 행동 루틴의 형태를 취합니다. 물론 모든 의미 규칙을 컴파일 시(또는 인터프리터의 프런트 엔드) 확인할 수 있는 것은 아닙니다. 가능한 것들을 언어의 정적 의미론이라고 합니다. 실행 시간(또는 인터프리터의 후반 단계에서)에 확인해야 하는 항목을 언어의 동적 의미론이라고 합니다. C는 동적 점검 방법이 거의 없습니다(설계자는 안전보다 성능을 더 선호함). 런타임에 다른 언어가 적용하는 규칙의 예는 다음과 같습니다.</p>\n<ul>\n<li>변수는 값이 지정되지 않은 경우 식에 사용되지 않습니다.10</li>\n<li>포인터는 유효한 개체를 참조하지 않는 한 참조 해제되지 않습니다.</li>\n<li>배열 첨자 식이 배열의 경계 내에 있습니다.</li>\n<li>산술 연산은 오버플로되지 않습니다.</li>\n</ul>\n<p>정적으로 규칙을 적용할 수 없는 경우 컴파일러는 종종 런타임에 적절한 검사를 수행하기 위한 코드를 생성하며, 프로그램을 중단하거나 검사 중 하나가 실패할 경우 예외를 생성합니다.용출은 단순히 검사하지 못할 수 있습니다. 에이다에서는 이러한 규칙을 어기는 프로그램이 오류라고 하며, C에서는 그 동작이 정의되지 않았다고 합니다.</p>\n<p><strong>EXAMPLE 1.24 GCD program abstract</strong></p>\n<p>구문 분석 트리는 문맥 없는 문법의 규칙 하에서 토큰의 특정 시퀀스가 어떻게 파생될 수 있는지를 완전하고 구체적으로 보여주기 때문에 때때로 구체적인 구문 트리라고 알려져 있습니다. 그러나 토큰 시퀀스가 유효하다는 것을 알게 되면 구문 분석 트리의 많은 정보는 추가 컴파일 단계와 관련이 없습니다. 정적 의미 구문 트리 규칙을 확인하는 과정에서 의미 분석기는 일반적으로 트리 내부에 있는 대부분의 “인공” 노드를 제거하여 구문 분석 트리를 추상 구문 트리(AST 또는 단순히 구문 트리)로 변환합니다. 의미 분석기는 식별자에서 기호 테이블 항목에 대한 포인터와 같은 유용한 정보를 사용하여 나머지 노드에 주석을 달기도 합니다. 특정 노드에 부착된 주석을 해당 속성이라고 합니다. GCD 프로그램의 구문 트리는 그림 1.6에 나와 있습니다.</p>\n<p><strong>EXAMPLE 1.25 Interpreting the syntax tree</strong></p>\n<p>많은 인터프리터는 실행 중인 프로그램을 나타내기 위해 주석이 달린 구문 트리를 사용합니다. 그러면 “thead”는 트리 통과에 해당합니다. 우리의 GCD 프로그램에서 통역사는 그림 1.6의 근원에서 시작하여 나무의 주요 척추에 있는 문장을 순서대로 방문합니다. 첫 번째 ”:=” 노드에서 인터프리터는 올바른 자식이 호출임을 알아차립니다. 따라서 getint 루틴(기호 테이블의 슬롯 3에 있음)을 호출하고 결과를 i(기호 테이블의 슬롯 5에 있음)에 할당합니다. 두 번째 ”:=” 노드에서 인터프리터는 마찬가지로 getint의 결과를 j에 할당합니다. 노드가 진행되는 동안 왼쪽 하위 항목(“thead=“)을 반복적으로 평가하고 결과가 참이면 오른쪽 하위 항목 아래에 있는 트리를 재귀적으로 걷습니다. 마지막으로, 노드의 왼쪽 하위가 false로 평가되면, 인터프리터는 최종 호출 노드로 이동하여 결과를 출력합니다.</p>\n<p>많은 컴파일러에서 주석이 달린 구문 트리는 프런트 엔드에서 백엔드로 전달되는 중간 형식을 구성합니다. 다른 컴파일러에서 의미 분석은 다른 중간 형식을 생성하는 트리(일반적으로 단일 패스)의 통과로 끝납니다. 그러한 하나의 일반적인 형태는 단순한 조립 언어의 단편과 노드가 닮은 제어 흐름 그래프로 구성됩니다.</p>\n<p><strong>Figure 1.6 Syntax tree and symbol table for the GCD program.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABRElEQVQ4y42T64qFMAyE+/5vqP9E5CCC4v1uly8w0i16dguhsU0mM2l013V51jRNvqoqv66rfetc+3+XU8K+775tW38cxw30Zt8KufByWRZ/nqfZ2/qriAs/mqYx6cju+97P82y+ioj9W6FfkgEArOs6S2Yfx9FAAIZ9URQWR5Ft2+4ijwzpIQGADMNgAICG7cC4Iw5QjBjsBoxflAQt+ZKuwgBrcUcc57fktybTAqSxh4WRDShy1XPFuHgE4rEgUEyRCiP1Wm0IR81pRJ5mjEB6isXJsMInX0qMYZ7nNi5ZlvmyLE0OZzAREAVIhpUANVZSQawBcojx25HIJcAxa2QTJyDiANfM4mMOBqAnSWK08dM0tR1Gel2kAa4dA0hSpcYAqYhMfAA+n48Fa4ifFoz1OBod4h3IGlL1o67rr/9vzDi0H2jXmkqM32omAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/a019b59f8ef409f3062e6bedc1a2d7df/37523/Untitled11.png\"\n        srcset=\"/static/a019b59f8ef409f3062e6bedc1a2d7df/e9ff0/Untitled11.png 180w,\n/static/a019b59f8ef409f3062e6bedc1a2d7df/f21e7/Untitled11.png 360w,\n/static/a019b59f8ef409f3062e6bedc1a2d7df/37523/Untitled11.png 720w,\n/static/a019b59f8ef409f3062e6bedc1a2d7df/a1792/Untitled11.png 780w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그림 1.5와의 대비: 구문 트리는 구문 분석 알고리즘을 구동하는 데만 필요한 세부 사항을 생략하고 프로그램의 필수 구조만 유지합니다.</p>\n<p>이상화된 기계입니다. 우리는 GCD 프로그램에 대한 제어 흐름 그래프가 그림 15.3에 나타나 있는 15장에서 이 옵션을 더 고려할 것입니다. 관련 컴파일러 제품군에서 여러 언어의 프런트 엔드와 여러 시스템의 백 엔드는 공통 중간 형식을 공유합니다.</p>\n<h3 id=\"163-target-code-generation\" style=\"position:relative;\"><a href=\"#163-target-code-generation\" aria-label=\"163 target code generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6.3 Target Code Generation</h3>\n<p><strong>EXAMPLE 1.26 GCD program assembly code</strong></p>\n<p>컴파일러의 코드 생성 단계는 중간 양식을 대상 언어로 변환합니다. 구문 트리에 포함된 정보를 고려할 때 올바른 코드를 생성하는 것은 보통 어려운 작업이 아닙니다(1.6.4절에서 볼 수 있듯이 좋은 코드를 생성하는 것은 더 어렵습니다). 어셈블리 또는 기계어를 생성하기 위해 코드 생성기는 기호 테이블을 통과하여 변수에 위치를 할당한 다음 프로그램의 중간 표현을 통과하여 변수 참조에 대한 로드 및 저장소를 생성하고 적절한 산술 연산, 테스트 및 분기를 흩뿌립니다. 우리의 GCD 예에 대한 단순한 코드는 x86 어셈블리 언어로 그림 1.7에 나타나 있습니다. 그것은 간단한 교육학 컴파일러에 의해 자동으로 생성되었습니다.</p>\n<p><strong>Figure 1.7 Naive x86 assembly language for the GCD program.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 115.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACOUlEQVQ4y43VC09qMRAEYP7//wNCEBSUlyiCoLzpzbfJnhxRuZLUtqfd6czstjZKKeXj46O8vb2V3W4Xff13Pp9j/a+/hj+z2Szaer0uDw8PZT6fl5eXl9hwPB7LarUqn5+f5fn5OcbWlstljDUkxFgPQAMfNptNub+/L4+Pj+X9/b0CzDUKDodD2W630dfbfr+P9QAU8Pr6GkG9Xq9iob9cLmU6nQZzAX+SDGyxWFSS9eYOOJ1OATgajQLQAbdawyYBZKPdbrfLZDIpg8GgdLvdSIo5K9KGDM7xF4YCyNMsCux0OjEHxENjvl5n+xqsksxDmSLRmHeymEkB7JDxeBzZTuk/MvQnE4Atr5QQeXrf2DEcDgPMAbJ6E1AgH23mW6vVCja+CQbY7/fj0FtyvzDMspFddZZ+YejAu7u76H13yHVyvpUNDzMpZJvr65IdZK7dTArTSWS2wib56ekp2Col6+SrT3X5X8nJkByymA/QXKCMa+Z8/k1uAGKVdzlrDjPBDsKItw6se/fr1QMCUOONetNI1ABiXS/s39hVkhMQE3cZQN5pBwLGXG1eZ/i6Hhv8AkCeLOoF8czYRsyASdBPvzrbhs15l7FRHsbY5fPF06xBh+bbh0w96/HamCgZTUCz2Qzp9X8BXh7lVH/WKDBOwG83hU9Ot4mfuTGfL+sYmWNoPcfirCFUAZJEBplZLgmoJt0aTI1lnCJz5cRfGEqvKmwyBOdpeb3y6sl6vtzku6LuN8/rsv8Bx+zvuXriON0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/99ac5e650262c2107be91674b8c9c4fc/37523/Untitled12.png\"\n        srcset=\"/static/99ac5e650262c2107be91674b8c9c4fc/e9ff0/Untitled12.png 180w,\n/static/99ac5e650262c2107be91674b8c9c4fc/f21e7/Untitled12.png 360w,\n/static/99ac5e650262c2107be91674b8c9c4fc/37523/Untitled12.png 720w,\n/static/99ac5e650262c2107be91674b8c9c4fc/f8067/Untitled12.png 726w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>어셈블리 언어 니모닉은 다소 모호하게 보일 수 있지만 각 줄의 주석(컴파일러에 의해 생성되지 않음!)은 그림 1.6과 1.7 사이의 대응 관계를 일반적으로 분명하게 만들 것입니다. 몇 가지 힌트: ebp, eax, ebx 및 edi는 레지스터입니다(특수 보관 위치, 수가 제한되어 있어 매우 빠르게 액세스할 수 있음). -8(%ebp)은 주소가 ebp 레지스터에 있는 위치 앞의 8바이트 메모리 위치를 의미합니다. 이 프로그램에서 ebp는 변수 i와 j를 찾을 수 있는 베이스 역할을 합니다. 서브루틴 호출 명령어에 대한 인수는 스택에 인자를 푸시하여 전달되며, 이 인수에 대한 인수는 스택의 최상위 포인터입니다. 반환 값은 레지스터 eax로 반환됩니다. 산술 연산은 두 번째 인수를 연산의 결과로 덮어씁니다.</p>\n<p>코드 생성기는 종종 심볼 디버거에서 나중에 사용할 수 있도록 대상 코드의 존재하지 않는 부분에 포함시켜 기호 테이블을 저장합니다.</p>\n<h3 id=\"164-code-improvement\" style=\"position:relative;\"><a href=\"#164-code-improvement\" aria-label=\"164 code improvement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6.4 Code Improvement</h3>\n<p><strong>Example 1.27 GCD program</strong></p>\n<p>코드 개선은 종종 최적화라고 부르지만, 절대적인 의미에서 최적의 결과를 만들어 내는 경우는 거의 없습니다. 이 컴파일 단계는 프로그램을 동일한 결과를 보다 효율적으로 계산하는 새로운 버전으로 변환하는 것을 목표로 하는 선택적 컴파일 단계입니다. 일부 개선 사항은 기계와 무관합니다. 이것은 중간 양식에서 변환으로 수행될 수 있습니다. 다른 개선 사항으로는 대상 머신(또는 대상 언어로 프로그램을 실행하는 모든 것)에 대한 이해가 필요합니다. 이러한 작업은 대상 프로그램에서 변환으로 수행되어야 합니다. 따라서 코드 개선은 종종 컴파일러 단계 목록에 두 번 나타납니다. 의미 분석 및 중간 코드 생성 직후와 대상 코드 생성 직후입니다. 그림 1.7의 코드에 우수한 코드 임프로스터를 적용하면 코드가 생성됩니다.</p>\n<p>예제 1.27 GCD 프로그램입니다.\n최적화는 예 1.2에 나와 있습니다. 두 프로그램을 비교해보면 개선된 버전이 훨씬 짧다는 것을 알 수 있습니다. 눈에 띄게 대부분의 짐과 가게가 없습니다. 기계 독립 코드 임프로버는 메인 루프를 실행하는 동안 i와 j를 레지스터에 보관할 수 있는지 확인할 수 있습니다. (예를 들어, 이 루프가 레지스터를 재사용하거나 i 또는 j를 수정하려고 할 수 있는 서브루틴에 대한 호출을 포함하고 있는 경우에는 그렇지 않습니다.) 그러면 기계별 코드 임팩터가 대상 시스템의 실제 레지스터에 i와 j를 할당할 수 있습니다. 내부 동작이 복잡한 최신 마이크로프로세서의 경우 컴파일러는 일반적으로 인간 어셈블리 언어 프로그래머보다 더 나은 코드를 생성할 수 있습니다.</p>\n<aside>\n💡 **CHECK YOUR UNDERSTANDING**\n<ul>\n<li>편찬의 주요 단계를 나열하고, 다음에 의해 수행된 작업을 설명합니다.</li>\n</ul>\n<p>각각</p>\n<ul>\n<li>해석의 일부로도 실행되는 단계를 나열합니다.</li>\n<li>스캐너에서 다음으로 프로그램이 전달되는 형태를 설명하십시오.</li>\n</ul>\n<p>구문 분석기, 구문 분석기에서 의미 분석기로, 의미 분석기에서 사용됩니다.\n중간 코드 생성기에 연결합니다.</p>\n<ul>\n<li>컴파일러의 프런트 엔드와 백 엔드를 구분하는 것은 무엇입니까?</li>\n<li>단계와 패스의 차이는 무엇입니까? 무엇을요?</li>\n</ul>\n<p>컴파일러가 여러 개의 패스를 갖는 것이 말이 됩니까?</p>\n<ul>\n<li>컴파일러의 기호 표의 목적은 무엇입니까?</li>\n<li>정적 의미론과 동적 의미론의 차이는 무엇입니까?</li>\n<li>현대 기계에서, 조립 언어 프로그래머들은 여전히 글을 쓰는 경향이 있습니까?</li>\n</ul>\n<p>좋은 컴파일러가 할 수 있는 것보다 더 나은 코드인가요? 왜 그런가요? 혹은 왜 그렇지 않은가요?</p>\n</aside>\n<h2 id=\"17-summary-and-concluding-remarks\" style=\"position:relative;\"><a href=\"#17-summary-and-concluding-remarks\" aria-label=\"17 summary and concluding remarks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.7 Summary and Concluding Remarks</h2>\n<p>이 장에서는 프로그래밍 언어 설계 및 구현에 대한 연구를 소개했습니다. 우리는 언어가 왜 이렇게 많은지, 무엇이 언어를 성공하게 하는지, 어떻게 연구를 위해 분류될 수 있는지, 독자가 그 연구를 통해 얻을 수 있는 이득은 무엇인지 등을 고려했습니다. 우리는 언어 디자인과 언어 구현이 서로 긴밀하게 연결되어 있다는 점에 주목했습니다. 분명히 구현은 언어의 규칙에 따라야 합니다. 동시에 언어 디자이너는 다양한 기능을 구현하는 것이 얼마나 쉬울지, 어려울지, 그리고 어떤 종류의 성능이 나타날지 고려해야 합니다. 언어 구현은 일반적으로 해석에 기반한 것과 컴파일에 기반한 것으로 구분됩니다. 그러나 이러한 접근법 간의 차이는 모호하며, 대부분의 구현에는 각각 조금씩 포함되어 있다는 점에 주목했습니다. 일반적으로, 우리는 실행이 다음과 같은 번역 단계에 의해 선행되는 경우 언어를 컴파일한다고 말합니다.</p>\n<ol>\n<li>프로그램의 구조(구조)와 의미(의미)를 모두 완벽하게 분석합니다.</li>\n<li>상당히 다른 형태로 동등한 프로그램을 제작합니다. 이 책에 있는 구현 자료의 대부분은 컴파일과 관련되어 있습니다.</li>\n</ol>\n<p>컴파일러는 일반적으로 일련의 단계로 구성됩니다. 검색, 구문 분석 및 시맨틱 분석과 같은 처음 몇 단계는 소스 프로그램을 분석합니다. 집합적으로 이러한 단계를 컴파일러의 프런트 엔드라고 합니다. 목표 코드 생성 및 기계별 코드 개선과 같은 마지막 몇 단계를 백엔드라고 합니다. 소스의 의미와 일치하는 대상 프로그램(가급적 빠른 프로그램)을 구축하는 역할을 합니다. 프런트 엔드와 백 엔드 사이에서 우수한 컴파일러는 광범위한 기계 독립 코드 개선을 수행합니다. 이 “미들 엔드”의 단계는 일반적으로 컴파일러 코드의 대부분을 구성하며 실행 시간의 대부분을 차지합니다.</p>\n<p>3장, 6장, 7장, 8장, 9장, 10장이 이 책의 나머지 부분을 구성합니다. 그것들은 프로그래머와 언어 구현자의 관점 모두에서 언어 설계의 근본적인 문제들을 다룹니다. 구현에 대한 논의를 지원하기 위해 2장과 4장에서는 컴파일러 프런트 엔드에 대해 이 서론에서 설명했던 것보다 더 자세히 설명합니다. 챕터 5에서는 어셈블리 레벨 아키텍처에 대한 개요를 제공합니다. 15장부터 17장까지는 어셈블러 및 링커, 런타임 시스템, 코드 개선 기술을 포함한 컴파일러 백엔드에 대해 설명합니다. 추가적인 언어 패러다임은 11장부터 14장까지 다룹니다. 부록 A에는 본문에서 언급된 주요 프로그래밍 언어가 계보 및 참고 문헌과 함께 나열되어 있습니다. 부록 B에는 “설계 및 구현” 사이드 바 목록이 있으며, 부록 C에는 번호가 매겨진 예제 목록이 있습니다.</p>\n<h2 id=\"18-exercises\" style=\"position:relative;\"><a href=\"#18-exercises\" aria-label=\"18 exercises permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.8 Exercises</h2>\n<p>1.1  Errors in a computer program can be classified according to when they are detected and, if they are detected at compile time, what part of the compiler detects them. Using your favorite imperative language, give an example of each of the following.</p>\n<ol>\n<li>A lexical error, detected by the scanner</li>\n<li>A syntax error, detected by the parser</li>\n<li>A static semantic error, detected by semantic analysis</li>\n<li>A dynamic semantic error, detected by code generated by the compiler</li>\n<li>An error that the compiler can neither catch nor easily generate code tocatch (this should be a violation of the language definition, not just a program bug)</li>\n</ol>\n<p>1.2  Consider again the Pascal tool set distributed by Niklaus Wirth (Example 1.15). After successfully building a machine language version of the Pascal compiler, one could in principle discard the P-code interpreter and the P-code version of the compiler. Why might one choose <em>not</em> to do so?</p>\n<p>1.3 Imperative languages like Fortran and C are typically compiled, while scripting languages, in which many issues cannot be settled until run time, are typically interpreted. Is interpretation simply what one “has to do” when compilation is infeasible, or are there actually some <em>advantages</em> to interpreting a language, even when a compiler is available?</p>\n<p>1.4  The gcd program of Example 1.20 might also be written</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token function\">getint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token function\">getint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> j<span class=\"token punctuation\">)</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">%</span> j<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span> j <span class=\"token operator\">=</span> j <span class=\"token operator\">%</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">putint</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Does this program compute the same result? If not, can you fix it? Under what circumstances would you expect one or the other to be faster?</p>\n<p>1.5  Expanding on Example 1.25, trace an interpretation of the gcd program on the inputs 12 and 8. Which syntax tree nodes are visited, in which order?</p>\n<p>1.6  Both interpretation and code generation can be performed by traversal of a syntax tree. Compare these two kinds of traversals. In what ways are they similar/different?</p>\n<p>1.7  In your local implementation of C, what is the limit on the size of integers? What happens in the event of arithmetic overflow? What are the  implications of size limits on the portability of programs from one machine/compiler to another? How do the answers to these questions differ for Java? For Ada? For Pascal? For Scheme? (You may need to find a manual.)</p>\n<p>1.8 The Unix make utility allows the programmer to specify <em>dependences</em> among the separately compiled pieces of a program. If file <em>A</em> depends on file <em>B</em> and file <em>B</em> is modified, make deduces that <em>A</em> must be recompiled, in case any of the changes to <em>B</em> would affect the code produced for <em>A</em>. How accurate is this sort of dependence management? Under what circumstances will it lead to unnecessary work? Under what circumstances will it fail to recompile something that needs to be recompiled?</p>\n<p>1.9 Why is it difficult to tell whether a program is correct? How do you go about finding bugs in your code? What kinds of bugs are revealed by testing? What kinds of bugs are not? (For more formal notions of program correctness, see the bibliographic notes at the end of Chapter 4.)</p>\n<h3 id=\"답\" style=\"position:relative;\"><a href=\"#%EB%8B%B5\" aria-label=\"답 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>답</h3>\n<p>1-1 C언어</p>\n<ol>\n<li>int 1a = 1;</li>\n<li>int main( {}</li>\n<li>int i; i++;</li>\n<li>for(; i++; ); {} //데드루프</li>\n<li>return 1/0 //정의되지 않은 동작</li>\n</ol>\n<p>1.2 언어를 더 확장하기 위해</p>\n<p>1.3 컴파일러 대신 인터프리터를 사용하는 이유는 유연성이 더 높고 진단이 더 우수하다. 소스 코드가 직접 실행되기 때문에 인터프리터는 우수한 소스 수준 디버거를 포함할 수 있다. 혹은 그저 언어 디자인 때문일 수도 있다.</p>\n<p>1.4 같은 결과가 나온다. 모듈러 연산을 사용하기 떄문에 기존보다 연산량이 월등히 줄어든다.</p>\n<p>1.5</p>\n<p>program → := → 5 → call → 3 →</p>\n<p>:= → 6 → call → 3 →</p>\n<p>while → ≠ → 5 → 6 →</p>\n<p>if → > → 5 → 6 →</p>\n<p>:= → 5 → - → 5 → 6 →</p>\n<p>while → ≠ → 5 → 6 →</p>\n<p>if → > → 5 → 6 →</p>\n<p>:= → 6 → - → 6 → 5 →</p>\n<p>while → ≠ → 5 → 6 →</p>\n<p>call → 4 →5</p>\n<p>1.6 컴파일러와 인터프리터의 프론트 엔드 구조는 동일하나 인터프리터는 intermediate form을 기계어로 번역하지 않고 직접 실행한다.</p>\n<p>1.7</p>\n<p>1.8</p>\n<p>1.9</p>\n<h2 id=\"19-explorations\" style=\"position:relative;\"><a href=\"#19-explorations\" aria-label=\"19 explorations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.9 Explorations</h2>\n<p>1.10</p>\n<ol>\n<li>What was the first programming language you learned? If you chose it, why did you do so? If it was chosen for you by others, why do you think they chose it? What parts of the language did you find the most difficult to learn?</li>\n<li>For the language with which you are most familiar (this may or may not be the first one you learned), list three things you wish had been differently designed. Why do you think they were designed the way they were? How would you fix them if you had the chance to do it over? Would there be any negative consequences, for example in terms of compiler complexity or program execution speed?</li>\n</ol>\n<p>1.11 Get together with a classmate whose principal programming experience is with a language in a different category of Figure 1.1. (If your experience is mostly in C, for example, you might search out someone with experience in Lisp.) Compare notes. What are the easiest and most difficult aspects of programming, in each of your experiences? Pick a simple problem (e.g., sorting, or identification of connected components in a graph) and solve it using each of your favorite languages. Which solution is more elegant (do the two of you agree)? Which is faster? Why?</p>\n<p>1.12</p>\n<ol>\n<li>If you have access to a Unix system, compile a simple program with the -S command-line flag. Add comments to the resulting assembly language file to explain the purpose of each instruction.</li>\n<li>Now use the -o command-line flag to generate a <em>relocatable object file</em>. Using appropriate local tools (look in particular for nm, objdump, or a symbolic debugger like gdb or dbx), identify the machine language corresponding to each line of assembler.</li>\n<li>Using nm, objdump, or a similar tool, identify the <em>undefined external symbols</em> in your object file. Now run the compiler to completion, to produce an <em>executable</em> file. Finally, run nm or objdump again to see what has happened to the symbols in part (b). Where did they come from—how did the linker resolve them?</li>\n<li>Run the compiler to completion one more time, using the -v commandline flag. You should see messages describing the various subprograms invoked during the compilation process (some compilers use a different letter for this option; check the man page). The subprograms may include a preprocessor, separate passes of the compiler itself (of ten two), probably an assembler, and the linker. If possible, run these subprograms yourself, individually. Which of them produce the files described in the previous subquestions? Explain the purpose of the various command-line flags with which the subprograms were invoked.</li>\n</ol>\n<p>1.13 Write a program that commits a dynamic semantic error (e.g., division by zero, access off the end of an array, dereference of a null pointer). What happens when you run this program? Does the compiler give you options to control what happens? Devise an experiment to evaluate the cost of runtime semantic checks. If possible, try this exercise with more than one language or compiler.</p>\n<p>1.14 C has a reputation for being a relatively “unsafe” high-level language. For example: it allows the programmer to mix operands of different sizes and types in many more ways than its “safer” cousins. The Unix lint utility can be used to search for potentially unsafe constructs in C programs. In effect, many of the rules that are enforced by the compiler in other languages are optional in C, and are enforced (if desired) by a separate program. What do you think of this approach? Is it a good idea? Why or why not?</p>\n<p>1.15 Using an Internet search engine or magazine indexing service, read up on the history of Java and C#, including the conflict between Sun and Microsoft over Java standardization. Some have claimed that C# was, at least in part, an attempt by Microsoft to undermine the spread of Java. Others point to philosophical and practical differences between the languages, and argue that C# more than stands on its merits. In hindsight, how would you characterize Microsoft’s decision to pursue an alternative to Java?</p>\n<h2 id=\"110-bibliographic-notes\" style=\"position:relative;\"><a href=\"#110-bibliographic-notes\" aria-label=\"110 bibliographic notes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.10 Bibliographic Notes</h2>\n<p>이 책의 컴파일러 지향 챕터들은 컴파일러를 만드는 방법을 설명하기 보다는 컴파일러가 무엇을 하는지에 대한 의미를 전달하려고 합니다. 훨씬 더 자세한 내용은 다른 문헌에서 찾아볼 수 있습니다. 선행 옵션은 Aho의 작업을 포함합니다.\n[ALSU07], Cooper and Torczon [CT04], Fischer 등 [FCL10]의 세 가지 분류가 있습니다. 다른 우수하고, 덜 최신화된 텍스트로는 Appel [App97]과 Grune 등이 있습니다 [GBJ+12]. 프로그래밍 언어 설계에 대해 널리 사용되는 텍스트에는 Louden [LL12], Sebesta [Seb15] 및 Sethi [Set96]의 텍스트가 포함됩니다.\n프로그래밍 언어의 역사에 대한 최고의 정보는 1978년, 1993년, 2007년에 컴퓨터 기계 협회가 후원한 컨퍼런스 진행에서 확인할 수 있습니다[Wex78, Ass93, Ass07]. 또 다른 훌륭한 참고 문헌은 1987년 호로비츠의 텍스트 [Hor87]입니다. 보다 광범위한 역사적 자료는 분기별 IEEE 컴퓨팅 역사 연보에서 확인할 수 있습니다. 프로그래밍 언어 디자인에서 개인의 취향의 중요성을 고려할 때, 일부 언어 비교는 강한 단어들의 의견으로 표시되어야 합니다. 초기의 예로는 Dijkstra [Dij82], Hoare [Hoa81], Kernighan [Ker81], Wirth [Wir85a]의 저서가 있습니다.\n대부분의 현대 소프트웨어 개발은 통합 프로그래밍 환경에서 이루어집니다. 이러한 환경에 대한 영향력 있는 전구체로는 심볼릭스 코퍼레이션[WMWM87]과 Smalltalk [Gol84]의 Interlisp [TM81] 및 Xerox Palo Alto 연구 센터의 Cedar [SZBH86] 환경이 있습니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#11-the-art-of-language-design\">1.1 The Art of Language Design</a></p>\n</li>\n<li>\n<p><a href=\"#12-the-programming-language-spectrum\">1.2 The Programming Language Spectrum</a></p>\n</li>\n<li>\n<p><a href=\"#13-why-study-programming-languages\">1.3 Why Study Programming Languages?</a></p>\n<ul>\n<li><a href=\"#check-your-understanding\"><strong>Check Your Understanding</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#14-compilation-and-interpretation\">1.4 Compilation and Interpretation</a></p>\n</li>\n<li>\n<p><a href=\"#15-programming-environments\">1.5 Programming Environments</a></p>\n</li>\n<li>\n<p><a href=\"#16-an-overview-of-compilation\">1.6 An Overview of Compilation</a></p>\n<ul>\n<li><a href=\"#161-lexical-and-syntax-analysis\">1.6.1 Lexical and Syntax Analysis</a></li>\n<li><a href=\"#162-semantic-analysis-and-intermediate-code-generation\">1.6.2 Semantic Analysis and Intermediate Code Generation</a></li>\n<li><a href=\"#163-target-code-generation\">1.6.3 Target Code Generation</a></li>\n<li><a href=\"#164-code-improvement\">1.6.4 Code Improvement</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#17-summary-and-concluding-remarks\">1.7 Summary and Concluding Remarks</a></p>\n</li>\n<li>\n<p><a href=\"#18-exercises\">1.8 Exercises</a></p>\n<ul>\n<li><a href=\"#%EB%8B%B5\">답</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#19-explorations\">1.9 Explorations</a></p>\n</li>\n<li>\n<p><a href=\"#110-bibliographic-notes\">1.10 Bibliographic Notes</a></p>\n</li>\n</ul>\n</div>","excerpt":"이 책은 Michael L. Scott - Programming Language Pragmatics을 번역 정리한 글입니다. 1. Introduction 최초의 전자 컴퓨터는 거대한 기계로 여러 개의 방을 가득 채우고, 공장만큼 전기를 소비했습니다. 1940년대에 수백만 달러의 비용이 들 정도였죠. 이 기계를 사용한 프로그래머들은 기계어로 프로그래밍 했습니다. 기계어는 프로세스를 직접 제어하여 적절한 시간에 데이터를 한 장소에서 다른 곳으로 이동시키는 일련의 비트입니다. 이정도의 상세 수준에서 프로그램을 지정하는 것은 매우 지루한 작업입니다. 다음 프로그램은 GCD 알고리즘을 x86머신의 기계어로 작성한 것입니다. 사람들이 더 큰 프로그램을 쓰기 시작하면서, 실수할 확률이 적은 표기법이 필요했습니다. 는 연산이 니모닉 약어로 표현될 수 있도록 발명되었습니다. 당사의 GCD 프로그램은 x86 어셈블리어로 다음과 같습니다. 어셈블리어는 원래 니모닉과 기계어 명령어 사이의 일대일 대응으…","frontmatter":{"date":"2022-01-14","title":"Programming Language Pragmatics: 1. Introduction","categories":"독서","author":"sjsjsj1246","emoji":"📙"},"fields":{"slug":"/book/plt/1-introduction/"}},"next":{"id":"8c817ddf-5f2f-5671-a770-37ed1445da95","html":"<h2 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h2>\n<ul>\n<li>타입스크립트란 무엇인가.</li>\n<li>타입스크립트는 자바스크립트와 어떤 관계인가</li>\n<li>타입스크립트의 타입들은 null이 가능한가, any type에서는 어떨까</li>\n<li>덕 타이핑이 가능할까.</li>\n</ul>\n<h2 id=\"타입스크립트의-특징\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"타입스크립트의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입스크립트의 특징</h2>\n<p>타입스크립트는 인터프리터로 실행되지 않으며 저수준 언어로 컴파일되는 것도 아닙니다.\n타입스크립트는 또다른 고수준 언어인 자바스크립트로 컴파일되며, 실행 역시 자바스크립트로 이루어집니다.</p>\n<h2 id=\"item-1-타입스크립트와-자바스크립트의-관계-이해\" style=\"position:relative;\"><a href=\"#item-1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%9D%B4%ED%95%B4\" aria-label=\"item 1 타입스크립트와 자바스크립트의 관계 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 1. 타입스크립트와 자바스크립트의 관계 이해</h2>\n<blockquote>\n<p>Typescript는 Javascript의 superset이다.</p>\n</blockquote>\n<ul>\n<li>\n<p>자바스크립트 파일은 js, jsx를 쓰는 반면 타입스크립트 파일은 ts, tsx를 씁니다. 타입스크립트는 자바스크립트를 포함하기 때문에 main.js를 main.ts로 바꾼다고 해도 달라지는 것은 없습니다.</p>\n</li>\n<li>\n<p>따라서 기존 코드를 그대로 유지하면서 일부분에만 타입스크립트를 적용할 수 있습니다.</p>\n</li>\n<li>\n<p>타입스크립트의 타입 체커는 에러 핸들링에 유용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// javascript</span>\n<span class=\"token keyword\">let</span> city <span class=\"token operator\">=</span> <span class=\"token string\">\"new tork city\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>city<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// typeError: city.toUppercase is not a function</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// javascript</span>\n<span class=\"token keyword\">let</span> city <span class=\"token operator\">=</span> <span class=\"token string\">\"new tork city\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>city<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'toUppercase' 속성이 'string' 형식에 없습니다.</span>\n<span class=\"token comment\">// 'toUpperCase'를 사용하시겠습니까?</span></code></pre></div>\n<p>city 변수가 문자열이라는 것을 알려주지 않아도 타입스크립트는 초기값으로부터 타입을 추론합니다.</p>\n</li>\n<li>\n<p>타입스크립트의 목표는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것입니다. 타입스크립트가 ‘정적’ 타입시스템이라는 것은 바로 이런 특징을 말하는 것입니다.</p>\n</li>\n<li>\n<p>오류가 발생하지는 않지만 의도와 다르게 동작하는 코드도 있습니다. 타입스크립트는 이러한 문제중 몇가지를 찾아내기도 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> states <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n\t<span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">capital</span><span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">capital</span><span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">capital</span><span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> state <span class=\"token keyword\">of</span> states<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>capitol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">// undefined</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> states <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n\t<span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">capital</span><span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">capital</span><span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span><span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">capital</span><span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> state <span class=\"token keyword\">of</span> states<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>capitol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">// undefined</span>\n<span class=\"token comment\">// 'capitol' 속성이 ...형식에 없습니다.</span>\n<span class=\"token comment\">// 'capital'을 사용하시겠습니까?</span></code></pre></div>\n</li>\n<li>\n<p>타입스크립트는 타입 구문 없이도 오류를 잡을 수 있지만, 타입 구문을 추가한다면 훨씬 더 많은 오류를 찾아낼 수 있습니다.</p>\n</li>\n<li>\n<p>코드의 <code class=\"language-text\">의도</code>가 무엇인지 타입 구문을 통해 타입스크립트에게 알려줄 수 있기 때문에 코드의 동작과 의도가 다른 부분을 찾을 수 있습니다.</p>\n</li>\n<li>\n<p>따라서 명시적으로 states를 선언하여 의도를 분명하게 하는 것이 좋습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">State</span> <span class=\"token punctuation\">{</span>\n\tname<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\tcapital<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> states<span class=\"token operator\">:</span> State<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n\t<span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> capitol<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> capitol<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">{</span>name<span class=\"token operator\">:</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> capitol<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t\t\t\t\t\t<span class=\"token comment\">// 개체 리터럴은 알려진 속성만 지정할 수 있지만 'State' 형식에 'capitol'이 없습니다. 'capital'을 쓰려고 했습니까?</span>\n<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> state <span class=\"token keyword\">of</span> states<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>capitol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>따라서 타입스크립트의 영역에는 자바스크립트 프로그램, 타입 체커를 통과한 자바스크립트 프로그램이 있습니다.</p>\n<ul>\n<li>모든 자바스크립트는 타입스크립트이지만, 일부 자바스크립트만 타입 체크를 통과합니다.</li>\n</ul>\n</li>\n<li>\n<p>타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 떄문에 런타임 오류를 발생시키는 코드를 찾아내려고 합니다.</p>\n</li>\n<li>\n<p>타입시스템이 정적 타입의 정확성을 보장해 줄 것 같지만 그렇지 않습니다. 타입 시스템의 목적은 오류를 발생시키는 코드를 미리 찾아내서 오류가 적은 코드를 작성하는 것입니다.</p>\n</li>\n</ul>\n<h2 id=\"item-2-타입스크립트-설정-이해하기\" style=\"position:relative;\"><a href=\"#item-2-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"item 2 타입스크립트 설정 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 2. 타입스크립트 설정 이해하기</h2>\n<ul>\n<li>\n<p>타입스크립트 컴파일러는 매우 많은 설정을 가지고 있습니다. 이 설정들은 커맨드라인을 사용해 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">$ tsc <span class=\"token operator\">--</span>noImplictAny program<span class=\"token punctuation\">.</span>ts</code></pre></div>\n<p>하지만 tsconfig.json 설정 파일을 사용하는 것이 유지보수와 협업 관점에서 더 좋습니다.</p>\n<p>tsc —init을 실행하여 설정 파일을 만듭니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n\t<span class=\"token property\">\"compoilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token property\">\"noImplicitAny\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>타입스크립트의 설정들은 어디서 소스파일을 찾을지, 어떤 종류의 출력을 생성할지 제어하는 내용들과 언어 자체의 핵심 요소들을 제어하는 설정도 있습니다.</p>\n</li>\n<li>\n<p>타입스크립트는 어떻게 설정하느냐에 따라 완전히 다른 언어처럼 느껴질 수 있으니 설정을 제대로 사용하려면 noImplicitAny와 strictNullChecks를 이해해야 합니다.</p>\n</li>\n<li>\n<p>noImplicitAny: 암시적인 any타입을 금지합니다.</p>\n<ul>\n<li>타입스크립트가 문제를 발견하기 수월해지고, 코드의 가독성이 좋아지며, 개발자의 생산성이 향상됩니다.</li>\n<li>이 속성을 해제할 때는 자바스크립트로 되어 있는 기존 프로젝트를 타입스크립트로 전환하는 상황에만 필요합니다.</li>\n</ul>\n</li>\n<li>\n<p>strictNullChecks: null과 undefined가 모든 타입에서 허용되는지 확인합니다.</p>\n<ul>\n<li>타입에 null을 허용하기 위해 명시적으로 드러내야 합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>null을 허용하지 않으려면 이 값이 어디서부터 왔는지 찾아야 하고, null을 체크하는 코드나 단언문을 추가해야 합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span> el<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'Ready'</span>\nel<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'Ready'</span></code></pre></div>\n<ul>\n<li>strictNullChecks는 null과 undefined 관련된 오류를 잡아내는 데 많은 도움이 되지만 코드 작성을 어렵게 합니다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"item-3-코드-생성과-타입이-관계없음을-이해하기\" style=\"position:relative;\"><a href=\"#item-3-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B4%80%EA%B3%84%EC%97%86%EC%9D%8C%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"item 3 코드 생성과 타입이 관계없음을 이해하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 3. 코드 생성과 타입이 관계없음을 이해하기</h2>\n<ul>\n<li>큰 그림에서 보면, 타입스크립트 컴파일러는 두가지 역할을 수행합니다.\n<ul>\n<li>최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 합니다.</li>\n<li>코드의 타입 오류를 체크합니다.</li>\n</ul>\n</li>\n<li>놀라운 점은 이 두가지가 서로 완벽히 독립적이라는 것입니다. 다시말해 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않습니다. 또한 그 자바스크립트의 실행 시점에도 타입은 영향을 미치지 않습니다.</li>\n<li>이를통해 타입스크립트가 할 수 있는 일과 할 수 없는 일을 짐작할 수 있습니다.</li>\n</ul>\n<h3 id=\"타입-오류가-있는-코드도-컴파일이-가능합니다\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%98%A4%EB%A5%98%EA%B0%80-%EC%9E%88%EB%8A%94-%EC%BD%94%EB%93%9C%EB%8F%84-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"타입 오류가 있는 코드도 컴파일이 가능합니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 오류가 있는 코드도 컴파일이 가능합니다.</h3>\n<blockquote>\n<p>컴파일은 타입 체크와 독립적으로 동작하기 떄문에, 타입 오류가 있는 코드도 컴파일이 가능합니다.</p>\n</blockquote>\n<ul>\n<li>타입스크립트 오류는 C나 자바같은 언어들의 경고와 비슷합니다. 문제가 될 만한 부분을 알려주지만, 그렇다고 빌드를 멈추지는 않습니다.</li>\n</ul>\n<blockquote>\n<p>코드에 오류가 있을 때 “컴파일에 문제가 있다”고 말하는 경우를 보았을겁니다. 그러나 이는 기술적으로 틀린 말입니다. 엄밀히 말하면 오직 코드 생성만이 컴파일이라고 할 수 있기 때문입니다. 작성한 타입스크립트가 유효한 자바스크립트라면 타입스크립트 컴파일러는 컴파일을 해냅니다. 그러므로 코드에 오류가 있을 때 “타입 체크에 문제가 있다”고 말하는 것이 더 정확한 표현입니다.</p>\n</blockquote>\n<ul>\n<li>코드에 오류가 있더라도 컴파일된 산출물이 나오는 것은 실제로 도움이 됩니다. 웹 애플리케이션을 만들면서 어떤 부분에 문제가 발생한다고 가정해보겠습니다. 타입스크립트는 여전히 컴파일된 산출물을 생성하기 때문에, 문제가 된 오류를 수정하지 않더라도 애플리케이션의 다른 부분을 테스트할 수 있습니다.</li>\n</ul>\n<h3 id=\"런타임에는-타입-체크가-불가능합니다\" style=\"position:relative;\"><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EB%8A%94-%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC%EA%B0%80-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"런타임에는 타입 체크가 불가능합니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>런타임에는 타입 체크가 불가능합니다.</h3>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Rectangle</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Shape</span> <span class=\"token operator\">=</span> Square <span class=\"token operator\">|</span> Rectangle<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateArea</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> Shape<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shape <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Rectangle</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// ~~~~~~~~~ 'Rectangle'은 형식만 참조하지만</span>\n                    <span class=\"token comment\">//           여기서는 값으로 사용되고 있습니다.</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">//         ~~~~~~ 'Shape' 형식에 'height' 속성이 없습니다.</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>instanceof 체크는 런타임에 일어나지만, <strong>Rectangle은 타입이기 떄문에 런타임 시점에 아무런 역할을 할 수 없습니다.</strong> 타입스크립트의 타입은 ‘제거가능’합니다. 실제로 자바스립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어버립니다.</p>\n<p>Shape 타입을 명확하게 하려면, 런타임에 타입 정보를 유지하는 방법이 필요합니다. 하나의 방법은 height 속성이 존재하는지 체크해보는 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Rectangle</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Shape</span> <span class=\"token operator\">=</span> Square <span class=\"token operator\">|</span> Rectangle<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateArea</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> Shape<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'height'</span> <span class=\"token keyword\">in</span> shape<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>속성 체크는 런타입에 접근 가능한 값에만 관련되지만, 타입 체커 역시도 shape의 타입을 Ractangle로 보정해 주기 떄문에 오류가 사라집니다.</p>\n<p>또다른 방봅으로는 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 ‘태그’ 기법이 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  kind<span class=\"token operator\">:</span> <span class=\"token string\">'square'</span><span class=\"token punctuation\">;</span>\n  width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Rectangle</span> <span class=\"token punctuation\">{</span>\n  kind<span class=\"token operator\">:</span> <span class=\"token string\">'rectangle'</span><span class=\"token punctuation\">;</span>\n  height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Shape</span> <span class=\"token operator\">=</span> Square <span class=\"token operator\">|</span> Rectangle<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateArea</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> Shape<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">.</span>kind <span class=\"token operator\">===</span> <span class=\"token string\">'rectangle'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 Shape 타입은 ‘태그된 유니온(tagged union)‘의 한 예입니다. 이 기법은 런타임에 타입 정보를 손쉽게 유지할 수 있기 때문에, 타입스크립트에서 흔하게 볼 수 있습니다.</p>\n<p>타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘다 사용하는 기법도 있습니다. 타입을 클래스로 만들면 됩니다. Square와 Rectangle을 클래스로 만들면 오류를 해결할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Rectangle</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Square</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">public</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Shape</span> <span class=\"token operator\">=</span> Square <span class=\"token operator\">|</span> Rectangle<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateArea</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> Shape<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shape <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Rectangle</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>width <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// OK</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>인터페이스는 타입으로만 사용 가능하지만, Rectangle을 클래스로 선언하면 타입과 값으로 모두 사용할 수 있으므로 오류가 없습니다.</p>\n<p>type Shape = Square | Rectangle 부분에서 Rectangle은 타입으로 참조되지만, shape instanceof Rectangle 부분에서는 값으로 참조됩니다.</p>\n<h3 id=\"타입-연산은-런타임에-영향을-주지-않습니다\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%97%B0%EC%82%B0%EC%9D%80-%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"타입 연산은 런타임에 영향을 주지 않습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 연산은 런타임에 영향을 주지 않습니다.</h3>\n<p>string 또는 nuber 타입인 값을 항상 number로 정제하는 경우를 가정해 보겠습니다. 다음 코드는 타입 체커를 통과하지만 잘못된 방법을 썼습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">asNumber</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> val <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드는 다음 자바스크립트 코드로 변환됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">asNumber</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>코드에 아무런 정제 과정이 없습니다. as number는 타입 연산이고 런타임 동작에는 아무런 영향을 미치지 않습니다. 값을 정제하기 위해서는 런타임의 타입을 체크하고 자바스크립트 연산을 통해 변환을 수행해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">asNumber</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span> <span class=\"token operator\">?</span> <span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"런타임-타입은-선언된-타입과-다를-수-있습니다\" style=\"position:relative;\"><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84-%ED%83%80%EC%9E%85%EC%9D%80-%EC%84%A0%EC%96%B8%EB%90%9C-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%8B%A4%EB%A5%BC-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"런타임 타입은 선언된 타입과 다를 수 있습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>런타임 타입은 선언된 타입과 다를 수 있습니다.</h3>\n<p>다음 함수를 보고 마지막의 console.log문이 실행될 수 있을까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">setLightSwitch</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token boolean\">true</span><span class=\"token operator\">:</span>\n      <span class=\"token function\">turnLightOn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token boolean\">false</span><span class=\"token operator\">:</span>\n      <span class=\"token function\">turnLightOff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I'm afraid I can't do that.</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>타입스크립트는 일반적으로 실행되지 못하는 dead코드를 찾아내지만 위 코드에서는 찾아내지 못합니다.</p>\n<p>위 코드의 value: boolean에서 : boolean은 타입 선언문입니다. 만약 value가 문자열이라면 default 케이스가 실행될 수도 있습니다.</p>\n<p>타입 체킹을 했으므로 그럴 일 없다고 생각하실 수 있겠지만 네트워크 호출로부터 받아온 값으로 함수를 실행하는 경우 데이터가 문자열일 수 있습니다.</p>\n<p>타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있습니다.</p>\n<h3 id=\"타입스크립트-타입으로는-함수를-오버로드-할-수-없습니다\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C%EB%8A%94-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C-%ED%95%A0-%EC%88%98-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다.</h3>\n<p>타입스크립트는 타입과 런타임의 동작이 무관하기 때문에 함수 오버로딩은 불가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>add에 대한 처음 두 개의 선언문은 타입 정보를 제공할 뿐입니다. 이 두선언문은 타입스크립트가 자바스크립트로 변환되면서 제거되며, 구현체만 남게 됩니다.</p>\n<h3 id=\"타입스크립트-타입은-런타임-성능에-영향을-주지-않습니다\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%83%80%EC%9E%85%EC%9D%80-%EB%9F%B0%ED%83%80%EC%9E%84-%EC%84%B1%EB%8A%A5%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다.</h3>\n<p>타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에 런타임의 성능에 아무런 영향을 주지 않습니다.</p>\n<p>타입스크립트의 정적 타입은 실제로 비용이 전혀 들지 않습니다.</p>\n<p>대신 다음 주의사항이 있습니다.</p>\n<ul>\n<li>런타임 오버헤드가 없는 대신, 타입스크립트 컴파일러는 “빌드타임”오버헤드가 있습니다. 타입스크립트 팀은 컴파일러 성능을 매우 중요하게 생각합니다. 따라서 컴파일은 일반적으로 상당히 빠른 편이며 특히 증분 빌드시에 더욱 체감됩니다. 오버헤드가 커지면, 빌드 도구에서 트랜스파일만(transpile only)을 선택하여 타입 체크를 건너뛸 수 있습니다.</li>\n<li>타입스크립트가 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤들르 감안할지, 호환성을 포기하고 성능중심의 네이티브 구현체를 선택할지의 문제에 맞닥뜨릴 수도 있습니다.예를 들어 제네레이터 함수가 ES5타깃으로 컴파일되려면, 타입스크립트 컴파일러는 호환성을 위한 특정 헬퍼 코드를 추가할 것입니다. 이런 경우가 제네레이터의 호환성을 위한 오버헤드 또는 성능을 위한 네이티브 구현체 선택의 문제입니다. 어떤 경우든지 호환서오가 성능 사이의 선택은 컴파일 타기소가 언어 레벨의 문제이며 여전히 타입과는 무관합니다.</li>\n</ul>\n<h2 id=\"item-4-구조적-타이핑에-익숙해지기\" style=\"position:relative;\"><a href=\"#item-4-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0\" aria-label=\"item 4 구조적 타이핑에 익숙해지기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 4. 구조적 타이핑에 익숙해지기</h2>\n<p>자바스크립트는 본질적으로 덕 타이핑 기반입니다.</p>\n<p>Duck Typing이란 객체가 어떤 타입에 걸맞은 변수와 메소드를 지니면 객체를 해당 타입에 속하는 것으로 간주하는 것입니다.</p>\n<p>만약 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Vector2D</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">NamedVector</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateLength</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> Vector2D<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> v<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> v<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> v<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> v1<span class=\"token operator\">:</span> Vector2D <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> v2<span class=\"token operator\">:</span> NamedVector <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Zee'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">calculateLength</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 5</span>\n<span class=\"token function\">calculateLength</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 5</span></code></pre></div>\n<p>Vector2D와 NamedVector에 대한 관계를 전혀 선언하지 않았는데도 정상적으로 동작합니다.</p>\n<p>NamedVactor의 구조가 Vector2D와 호환되기 때문입니다. 이를 구조적 타이핑이라고 합니다.</p>\n<p>구조적 타이핑 떄문에 문제가 발생하기도 합니다.</p>\n<p>3D 벡터와 벡터의 길이를 1로 만드는 정규화 함수를 작성합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Vector3D</span> <span class=\"token punctuation\">{</span>\n  x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n  z<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> Vector3D<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> <span class=\"token function\">calculateLength</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token operator\">:</span> v<span class=\"token punctuation\">.</span>x <span class=\"token operator\">/</span> length<span class=\"token punctuation\">,</span>\n    y<span class=\"token operator\">:</span> v<span class=\"token punctuation\">.</span>y <span class=\"token operator\">/</span> length<span class=\"token punctuation\">,</span>\n    z<span class=\"token operator\">:</span> v<span class=\"token punctuation\">.</span>z <span class=\"token operator\">/</span> length<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">nomalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> z<span class=\"token operator\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// { x: 0.6, y: 0.8, z: 1}</span></code></pre></div>\n<p>그러나 이 함수는 1보다 더 긴 길이를 가지는 벡터를 반환합니다.</p>\n<p>타입스크립트는 오류를 발견하지 못했습니다.</p>\n<p>calculateLength는 2D 벡터를 기반으로 연산하는 함수이지만 Vector3D가 2D Vector와 호환되기 때문에 발생한 문제입니다.</p>\n<p>함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉽습니다. 이러한 타입은 봉인된(sealed)또는 정확한(precise)타입이라고 불리면 타입스크립트 타입 시스템에서는 표현할 수 없습니다. 좋든 실든 타입은 열려 있습니다.</p>\n<p>이러한 특성 때문에 가끔 당황스러운 결과가 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">calculateLengthL1</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> Vector3D<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> length <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> axis <span class=\"token keyword\">of</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> coord <span class=\"token operator\">=</span> v<span class=\"token punctuation\">[</span>axis<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\">// ~~~~~~~ 'string'은 'Vecetor3D'의 인덱스를 사용할 수 없기에</span>\n               <span class=\"token comment\">//         엘리먼트는 암시적으로 any입니다.</span>\n    length <span class=\"token operator\">+=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>coord<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>axis는 Vector3D 타입인 v의 키 중 하나이기 떄문에 ‘x’, ‘y’, ‘z’중 하나여야 합니다. 그리고 이들은 모두 number이므로 coord의 타입이 number가 되어야 할 것으로 예상됩니다.</p>\n<p>그러나 다음과 같이 작성할 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> vec3D <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> z<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> address<span class=\"token operator\">:</span> <span class=\"token string\">'123 Broadway'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">calculateLengthL1</span><span class=\"token punctuation\">(</span>vec3D<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// NaN</span></code></pre></div>\n<p>구조적 타이핑때문에 address 속성을 가지는 vec3D가 인자로 전달되었고 axis타입은 어떤 타입도 될 수 있는것입니다.</p>\n<p>이런 경우에는 루프보다는 모든 속성을 각각 더하는 구현이 더 낫습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">calculateLengthL1</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> Vector3D<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>구조적 타이핑은 클래스와 관련된 할당문에서도 당황스러운 결과를 보여줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span> <span class=\"token punctuation\">{</span>\n  foo<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>foo <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">C</span></span><span class=\"token punctuation\">(</span><span class=\"token string\">'instance of C'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> d<span class=\"token operator\">:</span> <span class=\"token constant\">C</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> foo<span class=\"token operator\">:</span> <span class=\"token string\">'object literal'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// OK!</span></code></pre></div>\n<p>d가 C타입에 할당되는 이유는 d가 string타입의 foo 속성을 가지며 Object.prototype으로부터 비롯된 매개변수가 하나인 생성자를 가지므로 C타입에 할당이 가능한 것입니다.</p>\n<p>만약 C의 생성자에 단순 할당이 아닌 연산 로직이 존재한다면 d의 경우는 생성자를 실행하지 않으므로 문제가 발생합니다.</p>\n<p>이러한 부분이 C타입의 매개변수를 선언하여 C 또는 서브클래스임을 보장하는 C++이나 자바 같은 언어와 매우 다른 특징입니다.</p>\n<p>테스트를 작성할 때는 구조적 타이핑이 유리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Author</span> <span class=\"token punctuation\">{</span>\n  first<span class=\"token operator\">:</span> strng<span class=\"token punctuation\">;</span>\n  last<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getAuthors</span><span class=\"token punctuation\">(</span>database<span class=\"token operator\">:</span> PostgresDB<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Author<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> authorRows <span class=\"token operator\">=</span> database<span class=\"token punctuation\">.</span><span class=\"token function\">runQuery</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">SELECT FIRST, LAST FROM AUTHORS</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> authorRows<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>row <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>first<span class=\"token operator\">:</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> last<span class=\"token operator\">:</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>getAuthors 함수를 테스트하기 위해서는 모킹한 postgresDB를 생성해야 합니다. 그러나 구조적 타이핑을 활용하여 더 구체적인 인터페이스를 정의하는 것이 더 나은 방법입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\"><span class=\"token constant\">DB</span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">runQuery</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>sql<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getAuthors</span><span class=\"token punctuation\">(</span>database<span class=\"token operator\">:</span> <span class=\"token constant\">DB</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Author<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> authorRows <span class=\"token operator\">=</span> database<span class=\"token punctuation\">.</span><span class=\"token function\">runQuery</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">SELECT FIRST, LAST FROM AUTHORS</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> authorRows<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>row <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>first<span class=\"token operator\">:</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> last<span class=\"token operator\">:</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이와 같이 추상화를 함으로써 로직과 테스트를 특정한 구현으로부터 분리할 수 있습니다.</p>\n<h2 id=\"item-5-any-타입-지양하기\" style=\"position:relative;\"><a href=\"#item-5-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91%ED%95%98%EA%B8%B0\" aria-label=\"item 5 any 타입 지양하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Item 5. any 타입 지양하기</h2>\n<p>타입스크립트의 타입 시스템은 코드에 타입을 조금씩 추가할 수 있기 때문에 <strong>점진적</strong>이며 <strong><strong>언제든지 타입 체커를 해제할 수 있기 때문에 <strong>선택적</strong>입니다</strong>. 이 기능들의 핵심은 any타입입니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">let</span> age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\nage <span class=\"token operator\">=</span> <span class=\"token string\">'12'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ~~~ Type '\"12\"' is not assignable to type 'number'</span>\nage <span class=\"token operator\">=</span> <span class=\"token string\">'12'</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// OK</span></code></pre></div>\n<p>타입 선언을 추가하는 데에 시간을 쏟고 싶지 않아서, any 타입이나 타입 단언문(as any)을 사용하고 싶기도 할 겁니다. 그러나 일부 특별한 경우를 제외하고는 any를 사용하면 타입스크립트의 수많은 장점을 누릴 수 없게 됩니다.</p>\n<h3 id=\"any-타입에는-타입-안정성이-없습니다\" style=\"position:relative;\"><a href=\"#any-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%95%EC%84%B1%EC%9D%B4-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"any 타입에는 타입 안정성이 없습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>any 타입에는 타입 안정성이 없습니다.</h3>\n<p>앞선 예제에서 age는 number타입으로 선언되었습니다. 그러나 as any를 사용하여 string 타입을 할당할 수 있게 됩니다. 타입 체커는 선언에 따라 number타입으로 판단할 것이고 혼돈은 걷잡을 수 없게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">age <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// \"121\"</span></code></pre></div>\n<h3 id=\"any는-함수-시그니처를-무시해버립니다\" style=\"position:relative;\"><a href=\"#any%EB%8A%94-%ED%95%A8%EC%88%98-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%A5%BC-%EB%AC%B4%EC%8B%9C%ED%95%B4%EB%B2%84%EB%A6%BD%EB%8B%88%EB%8B%A4\" aria-label=\"any는 함수 시그니처를 무시해버립니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>any는 함수 시그니처를 무시해버립니다.</h3>\n<p>함수를 작성할 때는 시그니처를 명시해야 합니다. 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환합니다. 그러나 any 타입을 사용하면 이런 약속을 어길 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">calculateAge</span><span class=\"token punctuation\">(</span>birthDate<span class=\"token operator\">:</span> Date<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// COMPRESS</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// END</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> birthDate<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> <span class=\"token string\">'1990-01-19'</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">calculateAge</span><span class=\"token punctuation\">(</span>birthDate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// OK</span></code></pre></div>\n<p>birthData 매개변수는 string이 아닌 Date타입이어야 합니다. any 타입을 사용하면 calculateAge의 시그니처를 무시하게 됩니다. 자바스크립트에서는 종종 암시적으로 타입이 변환되기 때문에 이런 경우 특히 문제가 될 수 있습니다.</p>\n<h3 id=\"any-타입에는-언어-서비스가-적용되지-않습니다\" style=\"position:relative;\"><a href=\"#any-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EC%96%B8%EC%96%B4-%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%80-%EC%A0%81%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"any 타입에는 언어 서비스가 적용되지 않습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>any 타입에는 언어 서비스가 적용되지 않습니다.</h3>\n<p>어떤 심벌에 타입이 있다면 타입스크립트 언어 서비스는 자동완성 기능과 적걸한 도움말을 제공합니다. 그러나 any 타입인 심벌을 사용하면 아무런 도움을 받지 못합니다.</p>\n<p>타입스크립트의 모토는 확장 가능한 자바스크립트입니다. 확장의 중요한 부분은 바로 타입스크립트 경험의 핵심 요소인 언어 서비스입니다. 언어 서비스를 제대로 누려야 독자 여러분과 동료의 생산성이 향상됩니다.</p>\n<h3 id=\"any-타입은-코드-리펙터링-때-버그를-감춥니다\" style=\"position:relative;\"><a href=\"#any-%ED%83%80%EC%9E%85%EC%9D%80-%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8E%99%ED%84%B0%EB%A7%81-%EB%95%8C-%EB%B2%84%EA%B7%B8%EB%A5%BC-%EA%B0%90%EC%B6%A5%EB%8B%88%EB%8B%A4\" aria-label=\"any 타입은 코드 리펙터링 때 버그를 감춥니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>any 타입은 코드 리펙터링 때 버그를 감춥니다.</h3>\n<p>어떤 아이템을 선택할 수 있는 웹 애플리케이션을 만든다고 가정해 보겠습니다. 애플리케이션에는 onSelectItem 콜벡이 있는 컴포넌트가 있을겁니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ComponentProps</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">onSelectItem</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">renderSelector</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> ComponentProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> selectedId<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">handleSelectItem</span><span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  selectedId <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">renderSelector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>onSelectItem<span class=\"token operator\">:</span> handleSelectItem<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>여기서 onSelectItem에 아이템 객체를 필요한 부분만 전달하도록 컴포넌트를 개선해보겠습니다. 여기서는 id만 필요합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ComponentProps</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">onSelectItem</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>컴포넌트를 수정하고 타입 체크를 모두 통과했습니다. 하지만 handleSelectItem은 any 매개변수를 받습니다. 따라서 id를 전달받아도 무넺가 없다고 나옵니다. 그러나 id를 전달받으면 타입 체커를 통과함에도 불구하고 런타입에는 오류가 발생합니다.</p>\n<h3 id=\"any는-타입-설계를-감춰버립니다\" style=\"position:relative;\"><a href=\"#any%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A4%EA%B3%84%EB%A5%BC-%EA%B0%90%EC%B6%B0%EB%B2%84%EB%A6%BD%EB%8B%88%EB%8B%A4\" aria-label=\"any는 타입 설계를 감춰버립니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>any는 타입 설계를 감춰버립니다.</h3>\n<p>애플리케이션 상태 같은 객체를 정의하려면 꽤 복잡합니다. 상태 객체 안에 있는 수많은 속성의 타입을 일일이 작성해야 하는데, any타입을 사용하면 간단히 끝내버릴 수 있습니다.</p>\n<p>하지만 이때도 any를 사용하면 안됩니다. 상태 객체의 설계를 감춰버리기 때문입니다. 만약 동료가 코드를 검토해야 한다면 동료는 애플리케이션의 상태를 어떻게 변경했는지 코드부터 재구성해 봐야 합니다. 그러므로 설계가 명확히 보이도록 타입을 일일이 작성하는 것이 좋습니다.</p>\n<h3 id=\"any는-타입시스템의-신뢰도를-떨어뜨립니다\" style=\"position:relative;\"><a href=\"#any%EB%8A%94-%ED%83%80%EC%9E%85%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%8B%A0%EB%A2%B0%EB%8F%84%EB%A5%BC-%EB%96%A8%EC%96%B4%EB%9C%A8%EB%A6%BD%EB%8B%88%EB%8B%A4\" aria-label=\"any는 타입시스템의 신뢰도를 떨어뜨립니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>any는 타입시스템의 신뢰도를 떨어뜨립니다.</h3>\n<p>사람은 항상 실수를 합니다. 보통은 타입 체커가 실수를 잡아주고 코드의 신뢰도가 높아집니다. 그러나 런타임에 타입 오류를 발견하게 된다면 타입 체커를 신뢰할 수 없을 겁니다. 대규모 팀에 타입스크립트를 도입하려는 상황이라면 타입 체커를 신뢰할 수 없는 상황이 큰 문제가 될 겁니다. any타입을 쓰지 않으면 런타입에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있습니다.</p>\n<p>코드 내에 존재하는 수많은 any타입은 일을 더 어렵게 만듦니다. 타입 오류를 고쳐야 하고 여전히 머리속에는 실제 타입을 기억해 둘 필요가 있기 때문입니다. 타입이 실제 값과 일치한다면 타입 정보를 기억해 둘 필요가 없습니다. 타입스크립트가 타입 정보를 기억해 주기 때문입니다.</p>\n<h2 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h2>\n<p>&#x3C;이펙티브 타입스크립트> <a href=\"https://github.com/danvk\">Dan Vanderkam</a>, 프로그래밍 인사이트 (2021)</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%9C%EC%9A%94\">개요</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%8A%B9%EC%A7%95\">타입스크립트의 특징</a></p>\n</li>\n<li>\n<p><a href=\"#item-1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%9D%B4%ED%95%B4\">Item 1. 타입스크립트와 자바스크립트의 관계 이해</a></p>\n</li>\n<li>\n<p><a href=\"#item-2-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">Item 2. 타입스크립트 설정 이해하기</a></p>\n</li>\n<li>\n<p><a href=\"#item-3-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B4%80%EA%B3%84%EC%97%86%EC%9D%8C%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">Item 3. 코드 생성과 타입이 관계없음을 이해하기</a></p>\n<ul>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EC%98%A4%EB%A5%98%EA%B0%80-%EC%9E%88%EB%8A%94-%EC%BD%94%EB%93%9C%EB%8F%84-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%A9%EB%8B%88%EB%8B%A4\">타입 오류가 있는 코드도 컴파일이 가능합니다.</a></li>\n<li><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EB%8A%94-%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC%EA%B0%80-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%A9%EB%8B%88%EB%8B%A4\">런타임에는 타입 체크가 불가능합니다.</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EC%97%B0%EC%82%B0%EC%9D%80-%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\">타입 연산은 런타임에 영향을 주지 않습니다.</a></li>\n<li><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84-%ED%83%80%EC%9E%85%EC%9D%80-%EC%84%A0%EC%96%B8%EB%90%9C-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%8B%A4%EB%A5%BC-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\">런타임 타입은 선언된 타입과 다를 수 있습니다.</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C%EB%8A%94-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C-%ED%95%A0-%EC%88%98-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4\">타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다.</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%83%80%EC%9E%85%EC%9D%80-%EB%9F%B0%ED%83%80%EC%9E%84-%EC%84%B1%EB%8A%A5%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\">타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#item-4-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0\">Item 4. 구조적 타이핑에 익숙해지기</a></p>\n</li>\n<li>\n<p><a href=\"#item-5-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91%ED%95%98%EA%B8%B0\">Item 5. any 타입 지양하기</a></p>\n<ul>\n<li><a href=\"#any-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%95%EC%84%B1%EC%9D%B4-%EC%97%86%EC%8A%B5%EB%8B%88%EB%8B%A4\">any 타입에는 타입 안정성이 없습니다.</a></li>\n<li><a href=\"#any%EB%8A%94-%ED%95%A8%EC%88%98-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%A5%BC-%EB%AC%B4%EC%8B%9C%ED%95%B4%EB%B2%84%EB%A6%BD%EB%8B%88%EB%8B%A4\">any는 함수 시그니처를 무시해버립니다.</a></li>\n<li><a href=\"#any-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EC%96%B8%EC%96%B4-%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%80-%EC%A0%81%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\">any 타입에는 언어 서비스가 적용되지 않습니다.</a></li>\n<li><a href=\"#any-%ED%83%80%EC%9E%85%EC%9D%80-%EC%BD%94%EB%93%9C-%EB%A6%AC%ED%8E%99%ED%84%B0%EB%A7%81-%EB%95%8C-%EB%B2%84%EA%B7%B8%EB%A5%BC-%EA%B0%90%EC%B6%A5%EB%8B%88%EB%8B%A4\">any 타입은 코드 리펙터링 때 버그를 감춥니다.</a></li>\n<li><a href=\"#any%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A4%EA%B3%84%EB%A5%BC-%EA%B0%90%EC%B6%B0%EB%B2%84%EB%A6%BD%EB%8B%88%EB%8B%A4\">any는 타입 설계를 감춰버립니다.</a></li>\n<li><a href=\"#any%EB%8A%94-%ED%83%80%EC%9E%85%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%8B%A0%EB%A2%B0%EB%8F%84%EB%A5%BC-%EB%96%A8%EC%96%B4%EB%9C%A8%EB%A6%BD%EB%8B%88%EB%8B%A4\">any는 타입시스템의 신뢰도를 떨어뜨립니다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\">참고자료</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"2022-01-04","title":"Effective Typescript: 1. 타입스크립트 알아보기","categories":"Language","author":"sjsjsj1246","emoji":"✍️"},"fields":{"slug":"/effective-typescript/chapter1/"}},"prev":{"id":"5819ebbb-6211-53ff-b340-29885992de09","html":"<h2 id=\"1-1-변수\" style=\"position:relative;\"><a href=\"#1-1-%EB%B3%80%EC%88%98\" aria-label=\"1 1 변수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. 변수</h2>\n<h3 id=\"1-1-변수란-무엇인가-왜-필요한가\" style=\"position:relative;\"><a href=\"#1-1-%EB%B3%80%EC%88%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"1 1 변수란 무엇인가 왜 필요한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. 변수란 무엇인가? 왜 필요한가?</h3>\n<blockquote>\n<p><code class=\"language-text\">변수(variable)</code>는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.</p>\n</blockquote>\n<p>다음과 같은 자바스크립트 코드를 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token number\">10</span> <span class=\"token operator\">+</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>자바스크립트 엔진은 위 코드를 평가(evaluation)하기 위해 10, 20, + 라는 기호(리터럴literal과 연산자operator)의 의미를 알고 있어야 하며, 10 + 20이라는 표현식(expression)의 의미도 해석(파싱parsing)할 수 있어야 한다.</p>\n<p>자바스크립트 엔진이 + 연산을 수행하기 위해 먼저 피연산자(operand) 10, 20을 기억해야 한다. 컴퓨터는 이를 메모리에 저장하고 읽는다. CPU는 메모리에 있는 피연산자를 읽어 + 연산을 수행한 뒤 30이라는 값을 다른 메모리 공간에 저장한다.</p>\n<p>하지만 이대로는 30이라는 메모리 주소에 직접 접근하는 것 말고는 값을 재사용할 수 없다. 자바스크립트는 개발자가 메모리에 직접 접근하도록 허용하지 않으므로 30이라는 값에 접근할 수 없다.</p>\n<p>이를 해결하기 위해 변수라는 개념이 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>10 + 20을 통한 연산의 결과를 result라는 메모리 공간에 붙여진 이름을 통해 저장하여 재사용할 수 있게 됐다.</p>\n<p>변수에 값을 저장하는 것을 할당이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조라 한다.</p>\n<h3 id=\"1-2-변수-선언\" style=\"position:relative;\"><a href=\"#1-2-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8\" aria-label=\"1 2 변수 선언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-2. 변수 선언</h3>\n<blockquote>\n<p><code class=\"language-text\">변수 선언(declaration)</code>이란 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것이다.</p>\n</blockquote>\n<p>변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 떄는 var, let, const 키워드를 사용한다.</p>\n<p>let, const 키워드는 ES6에서 도입되었다.</p>\n<blockquote>\n<p><code class=\"language-text\">키워드</code>는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다.</p>\n</blockquote>\n<blockquote>\n<p><strong>ES5</strong> vs <strong>ES6</strong>\nvar 키워드는 여러 단점이 있다. block-level-scope를 지원하지 않고 function-level-scope를 지원한다는 것이다.\nES6는 ES5의 superset이며 ES5 환경에서도 트랜스파일러를 이용해 ES6를 컴파일 할 수 있다. (babel과 polyfill)</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> score<span class=\"token punctuation\">;</span></code></pre></div>\n<p>변수 선언에 의해 확보된 <code class=\"language-text\">메모리 공간</code>은 비어 있을 것으로 생각할 수 있으나 <code class=\"language-text\">확보된 메모리 공간</code>에는 자바스크립트 엔진에 의해 <code class=\"language-text\">undefined</code>라는 값이 암묵적으로 <code class=\"language-text\">할당</code>되어 <code class=\"language-text\">초기화</code>된다.(이것은 자바스크립트의 독특한 특징이다.)</p>\n<blockquote>\n<p><code class=\"language-text\">초기화(initialization)</code>는변수가 선언된 이후 최초로 값을 할당하는 것을 말한다.</p>\n</blockquote>\n<p>자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.</p>\n<ul>\n<li><strong>선언 단계</strong> - 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>\n<li><strong>초기화 단계</strong> - 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.</li>\n</ul>\n<p>초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 이러한 값을 <code class=\"language-text\">쓰레기 값(garbage value)</code>이라 한다. 하지만 자바스크립트는 암묵적으로 초기화를 수행하므로 이런 위험이 없다.</p>\n<p>선언하지 않은 식별자에 접근하면 <code class=\"language-text\">ReferenceError(참조에러)</code>가 발생한다.</p>\n<blockquote>\n<p>자바스크립트는 컴파일 언어이다.\nJavascript는 실행되기 전에 마이크로초(또는 그 이하) 시간동안 컴파일 된다.\n(JIT, with lazy compile and even hot re-compile 등 기술 참고)\nTokenizing/Lexing → Parsing → Code-Generation</p>\n</blockquote>\n<p>var a = 2;를 만나면</p>\n<ol>\n<li>컴파일러는 var 키워드를 보고 Scope에 해당 변수 선언을 요청한다. 그 후 엔진이 실행할 수 있는 코드를 생성한다 a = 2</li>\n<li>프로그램 실행 후 a = 2를 만난 엔진은 Scope에서 해당 a를 찾고 값을 할당하는 일을 한다. (LHS look-up)</li>\n</ol>\n<h3 id=\"1-3-변수-선언의-실행-시점과-변수-호이스팅\" style=\"position:relative;\"><a href=\"#1-3-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8%EC%9D%98-%EC%8B%A4%ED%96%89-%EC%8B%9C%EC%A0%90%EA%B3%BC-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85\" aria-label=\"1 3 변수 선언의 실행 시점과 변수 호이스팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-3. 변수 선언의 실행 시점과 변수 호이스팅</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//undefined</span>\n\n<span class=\"token keyword\">var</span> score<span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드에서 참조에러가 발생하지 않고 <code class=\"language-text\">undefined</code>가 출력이 되는 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.</p>\n<p>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.</p>\n<p>이때, 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문등)을 소스코드에서 찾아내 먼저 실행한다.</p>\n<p>그리고, 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄식 순차적으로 실행한다.</p>\n<p>즉, 자바스크립트 엔진은 변수 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행한다.</p>\n<p>이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 <code class=\"language-text\">호이스팅</code>이라 한다.</p>\n<h3 id=\"1-4-값의-할당\" style=\"position:relative;\"><a href=\"#1-4-%EA%B0%92%EC%9D%98-%ED%95%A0%EB%8B%B9\" aria-label=\"1 4 값의 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-4. 값의 할당</h3>\n<p>변수에 값을 할당할 때는 <code class=\"language-text\">할당(assignment) 연산자 =</code>를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.</p>\n<p>변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 <code class=\"language-text\">값의 할당</code>은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n\n<span class=\"token keyword\">var</span> score<span class=\"token punctuation\">;</span>\nscore <span class=\"token operator\">=</span> <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>score<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 80</span></code></pre></div>\n<p>변수에 값을 할당할 때는 이전 값 <code class=\"language-text\">undefined</code>가 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다.</p>\n<h3 id=\"1-5-값의-재할당\" style=\"position:relative;\"><a href=\"#1-5-%EA%B0%92%EC%9D%98-%EC%9E%AC%ED%95%A0%EB%8B%B9\" aria-label=\"1 5 값의 재할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-5. 값의 재할당</h3>\n<p><code class=\"language-text\">재할당</code>이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 <code class=\"language-text\">할당</code>하는 것을 말한다.</p>\n<p>var 키워드로 선언한 변수는 선언과 동시에 <code class=\"language-text\">undefined</code>로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 <code class=\"language-text\">재할당</code>이다.</p>\n<p>값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 <code class=\"language-text\">상수</code>다.</p>\n<p><code class=\"language-text\">상수</code>는 단 <code class=\"language-text\">한 번만</code> 할당할 수 있는 <code class=\"language-text\">변수</code>다.</p>\n<p><code class=\"language-text\">변수에 값을 재할당</code>할때는 처음에 변수에 값을 할당할 때처럼 이전 값이 저장되어 있던 메모리 공간에 새로운 값을 저장하는 것이 아니라 <code class=\"language-text\">새로운 메모리 공간</code>을 확보하고 그 <code class=\"language-text\">메모리 공간에 새로운 값을 저장하는 것</code>이다.</p>\n<p>이후, 어떤 식별자와도 연결되어 있지 않은 불필요한 값들은 <code class=\"language-text\">가비지 컬렉터</code>에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다.</p>\n<blockquote>\n<p>자바스크립트에서 재할당을 할 때는 기존에 있던 메모리 공간에 값을 할당하지 않습니다.\n만약 기존에 있던 메모리 공간의 크기가 할당할 값보다 작다면 그 메모리를 늘려주는 작업도 해야 할 겁니다. 비용이 많이 들죠 그렇지 않고 다른 메모리 공간에 값을 저장해놓고 식별자 foo는 그 메모리 공간을 가리키기만 하면 되겠죠\n즉 메모리의 효율적인 처리를 위해 이런 동작을 하고 재할당이 일어날 때 마다 새로운 메모리 공간을 할당하며 기존에 있던 메모리 공간은 가비지 컬렝터의 대상이 됩니다</p>\n</blockquote>\n<h2 id=\"2-스코프\" style=\"position:relative;\"><a href=\"#2-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"2 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 스코프</h2>\n<h3 id=\"2-1-스코프란\" style=\"position:relative;\"><a href=\"#2-1-%EC%8A%A4%EC%BD%94%ED%94%84%EB%9E%80\" aria-label=\"2 1 스코프란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. 스코프란?</h3>\n<blockquote>\n<p><code class=\"language-text\">스코프(Scope)</code>는 식별자가 유효한 범위를 말한다.</p>\n</blockquote>\n<ul>\n<li>자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징이 있다.</li>\n<li>var 키워드로 선언한 변수와 let 또는 const 키워드로 선언한 변수의 스코프도 다르게 동작한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> var1 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//코드 가장 바깥 영역에서 선언한 변수</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> var2 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 함수 내에서 선언한 변수</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError : var4 is not defined</span></code></pre></div>\n<p>모든 식별자 (변수이름, 함수이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위, 즉 스코프가 결정된다.</p>\n<p><strong>식별자결정</strong> : 자바스크립트 엔진은 이름이 같은 두 변수 중 어떤 변수를 참조해야 할 것인지를 결정</p>\n<p>따라서 <code class=\"language-text\">스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙</code>이라고도할 수 있다.</p>\n<blockquote>\n<p>💡 코드의 문맥은 렉시컬환경으로 이뤄진다. 이를 구현한 것이 실행컨텍스트이며, 모든 코드는 실행컨텍스트에서 평가되고 실행된다.</p>\n</blockquote>\n<h4 id=\"2-1-1-스코프는-네임스페이스다\" style=\"position:relative;\"><a href=\"#2-1-1-%EC%8A%A4%EC%BD%94%ED%94%84%EB%8A%94-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8B%A4\" aria-label=\"2 1 1 스코프는 네임스페이스다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1-1. 스코프는 네임스페이스다.</h4>\n<p>스코프 내에서 식별자는 유일해야 하지만, 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.</p>\n<h4 id=\"2-1-2-var-키워드로-선언한-변수의-중복선언\" style=\"position:relative;\"><a href=\"#2-1-2-var-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%9C-%EB%B3%80%EC%88%98%EC%9D%98-%EC%A4%91%EB%B3%B5%EC%84%A0%EC%96%B8\" aria-label=\"2 1 2 var 키워드로 선언한 변수의 중복선언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1-2. var 키워드로 선언한 변수의 중복선언</h4>\n<p>var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수 값이 재할당되어 변경되는 부작용을 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// var로 선언된 변수는 같은 스코프 내에서 중복선언이 허용된다.</span>\n  <span class=\"token comment\">// 아래 변수 선언문은 자바스크립트 엔진에 의해서 var 키워드가 없는 것처럼 동작한다.</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span></code></pre></div>\n<p>let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//SyntaxError: Identifier 'x' has already been declared</span></code></pre></div>\n<h3 id=\"2-2-스코프-종류\" style=\"position:relative;\"><a href=\"#2-2-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A2%85%EB%A5%98\" aria-label=\"2 2 스코프 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. 스코프 종류</h3>\n<p>코드는 전역과 지역으로 구분할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>설명</th>\n<th>스코프</th>\n<th>변수</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>전역</td>\n<td>코드의 가장 바깥 영역</td>\n<td>전역 스코프</td>\n<td>전역변수</td>\n</tr>\n<tr>\n<td>지역</td>\n<td>함수 몸체 내부</td>\n<td>지역 스코프</td>\n<td>지역변수</td>\n</tr>\n</tbody>\n</table>\n<p>변수는 자신이 전언된 위치(전역/지역)에 의해 자신이 유효한 범위인 스코프(전역 스코프/지역 스코프)가 결정된다.</p>\n<h4 id=\"2-2-1-전역\" style=\"position:relative;\"><a href=\"#2-2-1-%EC%A0%84%EC%97%AD\" aria-label=\"2 2 1 전역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2-1. 전역</h4>\n<ul>\n<li>코드의 가장 바깥 영역, 전역에 변수를 선언하면 전역 스코프를 갖는 <strong>전역 변수</strong>가 된다,</li>\n<li>전역변수는 어디서든 참조 가능하다.</li>\n</ul>\n<h4 id=\"2-2-2-지역\" style=\"position:relative;\"><a href=\"#2-2-2-%EC%A7%80%EC%97%AD\" aria-label=\"2 2 2 지역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2-2. 지역</h4>\n<ul>\n<li>함수 몸체 내부를 말한다. 지역에 변수를 선언하면 지역 스코프를 갖는 <strong>지역변수</strong>가 된다,</li>\n<li>지역 변수는 자신의 지역 스코프와, 하위 지역스코프에서 유효하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token string\">\"global\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token string\">\"local\"</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// local</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//global</span></code></pre></div>\n<p>foo 함수 내부에서 선언된 x는 지역변수다. 지역변수 x는 자신이 선언된 foo 내부에서만 참조 가능하다. 하지만 이 지역변수 x를 전역 또는 foo 함수 내부 이외의 지역에서 참조하면 참조 에러가 발생한다.</p>\n<p>그런데 foo 함수 외부에도 전역변수 x가 선언되어있다. 이 경우에 foo함수 내에서 x 변수를 참조하면 전역변수 x를 참조하는 것이 아니라 foo 함수 내부에 있는 x를 참조한다. 이는 자바스크립트 엔진이 <strong>스코프 체인</strong>을 통해 참조할 변수를 검색(identifier resolution)했기 때문이다.</p>\n<h3 id=\"2-3-스코프-체인\" style=\"position:relative;\"><a href=\"#2-3-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8\" aria-label=\"2 3 스코프 체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. 스코프 체인</h3>\n<ul>\n<li>함수의 중첩 : 함수 몸체 내부에서 함수가 정의된 것</li>\n<li>중첩 함수 : 함수 몸체 내부에서 정의한 함수</li>\n<li>외부함수 : 중첩 함수를 포함하는 함수</li>\n</ul>\n<p>함수가 중첩될 수 있기 때문에 지역 스코프도 중첩될 수 있다. 이는 <strong>스코프가</strong> 함수의 중첩에 의해 <strong>계층적 구조</strong>를 갖는다는 것을 의미한다.</p>\n<p>중첩함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 <code class=\"language-text\">계층적 구조</code>를 갖는다. 이때 <strong>외부 함수의 지역 스코프</strong>를 <strong>중첩 함수의 상위 스코프</strong>라고 한다.</p>\n<blockquote>\n<p>💡 모든 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다. 모든 지역 스코프의 최상위 스코프는 전역 스코프이다.</p>\n</blockquote>\n<ul>\n<li><strong>스코프 체인은 물리적인 실체로 존재한다.</strong>\n<ul>\n<li>자바스크립트 엔진은 코드실행에 앞서 <strong>렉시컬 환경</strong>을 실제로 <strong>생성</strong>한다.</li>\n<li><strong>변수 선언</strong>이 되면 변수 식별자가 이 렉시컬 환경에 키로 등록된다.</li>\n<li><strong>변수할당</strong>이 일어나면 렉시컬 환경의 변수 식별자에 해당하는 값을 변경한다.</li>\n<li><strong>변수 검색</strong>도 이 렉시컬 환경 상에서 일어난다.</li>\n<li><strong>변수를 참조할 때</strong> 자바스크립트 엔진은 <strong>스코프 체인</strong>을 통해 변수를 참조하는 코드의 스코프에서 시작하여 <strong>상위 스코프 방향으로 이동하며</strong> 선언된 변수를 <strong>검색</strong>한다. 이를 통해 <code class=\"language-text\">상위 스코프에서 선언한 변수를 하위 스코프에서도 참조 가능하다.</code></li>\n</ul>\n</li>\n<li><strong>스코프 체인은 렉시컬 환경을 단방향으로 연결한 것이다.</strong>\n<ul>\n<li>전역 렉시컬 환경은 코드가 로드되면 곧바로 생성된다.</li>\n<li>함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-1-스코프-체인에-의한-변수-검색\" style=\"position:relative;\"><a href=\"#2-3-1-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8%EC%97%90-%EC%9D%98%ED%95%9C-%EB%B3%80%EC%88%98-%EA%B2%80%EC%83%89\" aria-label=\"2 3 1 스코프 체인에 의한 변수 검색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3-1. 스코프 체인에 의한 변수 검색</h4>\n<ul>\n<li>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있다.</li>\n<li>하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.</li>\n<li>스코프의 계층적 구조는 부자 관계로 이뤄진 상속과 유사하다. ( 상속 : 상속을 통해 부모의 자산을 자식이 자유롭게 사용할 수 있지만 자식의 자산을 부모가 사용할 순 없다.)</li>\n</ul>\n<h4 id=\"2-3-2-스코프-체인에-의한-함수-검색\" style=\"position:relative;\"><a href=\"#2-3-2-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8%EC%97%90-%EC%9D%98%ED%95%9C-%ED%95%A8%EC%88%98-%EA%B2%80%EC%83%89\" aria-label=\"2 3 2 스코프 체인에 의한 함수 검색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3-2. 스코프 체인에 의한 함수 검색</h4>\n<ul>\n<li>함수도 식별자에 할당되기 때문에 스코프를 갖는다. 사실 함수는 식별자에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바가 없다.</li>\n<li>따라서 스코프를 <strong>식별자를 검색하는 규칙</strong>이라고 표현하는 편이 좀 더 적합하다.</li>\n</ul>\n<h3 id=\"2-4-함수-레벨-스코프\" style=\"position:relative;\"><a href=\"#2-4-%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"2 4 함수 레벨 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4. 함수 레벨 스코프</h3>\n<p>지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다. 이는 코드 블록이 아닌 **<code class=\"language-text\">함수에 의해서만 지역 스코프가 생성된다</code>**는 의미다.</p>\n<ul>\n<li><strong>블록 레벨 스코프(block level scope)</strong>\n모든 코드 블록(if, for, while, try/catch 등)은 지역 스코프를 만든다.</li>\n<li><strong>함수 레벨 스코프(function level scope)</strong>\n<strong>var 키워드</strong>로 선언된 변수는 오로지 함수의 <strong>코드 블록(함수 몸체)</strong> 만을 <strong>지역 스코프</strong>로 인정한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// x는 전역 변수.</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10, 값이 재할당됨</span></code></pre></div>\n<p>var 키워드로 선언된 변수는 함수 레벨 스코프만 인정하기 때문에 <code class=\"language-text\">함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언</code>되었다고 하더라도 <strong>전역변수</strong>이다.</p>\n<blockquote>\n<p>따라서 전역변수 x는 중복 선언되고, 그 결과 전역변수의 재할당이 일어난다.</p>\n</blockquote>\n<h3 id=\"2-5-렉시컬-스코프\" style=\"position:relative;\"><a href=\"#2-5-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"2 5 렉시컬 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-5. 렉시컬 스코프</h3>\n<ul>\n<li><strong>동적 스코프(dynamic scope)</strong>\n<ul>\n<li><strong>함수를 어디서 호출했는지</strong>에 따라 함수의 상위 스코프를 결정한다.</li>\n</ul>\n</li>\n<li><strong>렉시컬 스코프(lexical scope) 또는 정적 스코프(static scope)</strong>\n<ul>\n<li><strong>함수를 어디서 정의했는지에 따라</strong> 함수의 상위 스코프를 결정한다.</li>\n</ul>\n</li>\n</ul>\n<p>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</p>\n<p>즉 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span></code></pre></div>\n<p>결론적으로 var 키워드를 사용하여 변수를 정의하면</p>\n<ul>\n<li>함수 레벨 스코프를 따라 스코프가 결정된다.</li>\n<li>렉시컬 스코프에 의해 상위 스코프를 결정한다.</li>\n</ul>\n<h2 id=\"3-전역-변수의-문제점\" style=\"position:relative;\"><a href=\"#3-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"3 전역 변수의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 전역 변수의 문제점</h2>\n<h3 id=\"3-1-변수의-생명-주기\" style=\"position:relative;\"><a href=\"#3-1-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0\" aria-label=\"3 1 변수의 생명 주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 변수의 생명 주기</h3>\n<h4 id=\"3-1-1-지역-변수의-생명-주기\" style=\"position:relative;\"><a href=\"#3-1-1-%EC%A7%80%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0\" aria-label=\"3 1 1 지역 변수의 생명 주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1-1. 지역 변수의 생명 주기</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token string\">'global'</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">undefined</span>\n    <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token string\">'local'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//global</span></code></pre></div>\n<blockquote>\n<p>지역 변수의 생명 주기는 함수의 생명 주기와 일치한다</p>\n</blockquote>\n<ul>\n<li>함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 따라서 <strong>변수는 자신이 등록된 스코프가 소멸될 때 (메모리가 해제될 때)까지 유효하다</strong></li>\n<li>할당된 메모리 공간은 더이상 그 누구도 참조하지 않을 때 가비지 콜렉터에 의해 메모리 풀에 반환된다.</li>\n</ul>\n<p><strong>지역 변수가 함수보다 오래 생존하는 경우도 있다</strong></p>\n<p><strong>누군가 메모리 공간을 참조한다면,</strong> 해제되지 않고 확보된 상태로 남아있게 된다.<br>\n스코프 또한 마찬가지로 <strong>누군가 스코프를 참조하고 있다면</strong> 스코프는 소멸하지 않고 생존하게 된다.<br>\n일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸하지만, <strong>누군가 스코프를 참조한다면</strong> 스코프는 해제되지 않고 생존한다</p>\n<h4 id=\"3-1-2전역-변수의-생명-주기\" style=\"position:relative;\"><a href=\"#3-1-2%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0\" aria-label=\"3 1 2전역 변수의 생명 주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1-2.전역 변수의 생명 주기</h4>\n<p>함수와 달리 전역변수는 명시적 호출 없이 실행된다<br>\n특별한 진입점 없이 코드가 로드되자마자 해석되고 실행된다\n전역 코드는 반환문을 사용할 수 없으므로, 마지막 문이 실행되어 실행할 문이 없을때 종료한다</p>\n<p><strong>var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다</strong></p>\n<ul>\n<li>전역 변수의 생명 주기는 전역 객체의 생명주기와 일치한다</li>\n</ul>\n<p>전역객체란 코드가 실행되기 이전에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이다</p>\n<p>클라이언트 사이드 환경에서는(브라우저) window, 서버사이드 환경에서는(node.js)gloabl 객체를 의미한다</p>\n<p>전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array … )와 환경에 따른 호스트 객체(Web API, node.js의 호스트API), 그리고 var 키워드로 선언한 전역변수와 전역 함수를 프로퍼티로 갖는다</p>\n<ul>\n<li>브라우저 환경의 전역 객체는 window이고, var 키워드로 선언한 변수는 전역 객체 window의 프로퍼티이다\n<ul>\n<li>전역 객체 window는 웹페이지를 닫기 전까지 유효하므로, var 키워드로 선언한 전역 변수의 생명 주기는 전역객체의 생명주기와 일치한다</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-전역-변수의-문제점\" style=\"position:relative;\"><a href=\"#3-2-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"3 2 전역 변수의 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. 전역 변수의 문제점</h3>\n<p>문제점 <strong>1. 암묵적 결합</strong><br>\n전역 변수를 선언하면, 모든 코드가 전역변수를 참조하고, 변경할 수 있는 암묵적 결합을 허용하는것이다<br>\n-> 변수의 유효 범위가 크면 클수록 코드의 가독성이 나빠지고, 의도치 않게 상태가 변경될 수 있는 위험성이 높아진다</p>\n<p>문제점 <strong>2. 긴 생명주기</strong><br>\n긴 생명주기를 가짐으로써 생기는 문제는<br>\n-> 메모리 리소스를 오랜기간 소비한다\n-> 상태 변경에 의한 오류가 발생할 확률이 크다</p>\n<p>문제점 <strong>3. 스코프 체인 상에서 종점에 존재</strong><br>\n-> 변수 검색 시, 가장 마지막에 검색되어 검색속도가 가장 느리다, 검색속도의 차이가 크지는 않지만 속도의 차이는 분명히 있다</p>\n<p>문제점 <strong>4. 네임스페이스 오염</strong>\njs의 문제점은 파일이 분리되어 있다고 해도 하나의 전역 스코프를 공유한다는 것,\n-> 다른 파일 내에 동일한 이름으로 변수를 사용할 경우, 예상치 못한 결과를 가져올 수 있다.</p>\n<h3 id=\"3-3-전역-변수의-사용을-억제하는-방법\" style=\"position:relative;\"><a href=\"#3-3-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%96%B5%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"3 3 전역 변수의 사용을 억제하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3. 전역 변수의 사용을 억제하는 방법</h3>\n<blockquote>\n<p>전역변수를 반드시 사용해야 할 이유가 없다면 지역변수를 사용해야 한다,<br>\n변수의 스코프는 좁을수록 좋다</p>\n</blockquote>\n<h4 id=\"3-3-1-즉시-실행-함수\" style=\"position:relative;\"><a href=\"#3-3-1-%EC%A6%89%EC%8B%9C-%EC%8B%A4%ED%96%89-%ED%95%A8%EC%88%98\" aria-label=\"3 3 1 즉시 실행 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-1. 즉시 실행 함수</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 에러!!</span></code></pre></div>\n<p>모든 코드를 즉시실행함수로 감싸면 모든 변수는 즉시실행함수의 지역변수가 된다<br>\n-> 전역 변수의 사용을 제한할 수 있다</p>\n<h4 id=\"3-3-2-네임스페이스-객체\" style=\"position:relative;\"><a href=\"#3-3-2-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4\" aria-label=\"3 3 2 네임스페이스 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-2. 네임스페이스 객체</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token constant\">MYAPP</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 전역 네임스페이스 객체</span>\n<span class=\"token constant\">MYAPP</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Lee'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MYAPP</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// Lee</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">var</span> <span class=\"token constant\">MYAPP</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">MYAPP</span><span class=\"token punctuation\">.</span>person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">//네임스페이스를 계층적으로 구성할 수도 있다.</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span><span class=\"token string\">\"Lee\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">address</span><span class=\"token operator\">:</span><span class=\"token string\">\"Seoul\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">MYAPP</span><span class=\"token punctuation\">.</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Lee</span>\n</code></pre></div>\n<p>전역에 네임스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다<br>\n네임스페이스 분리로 식별자 충돌을 방지할 수는 있으나, 객체 자체가 전역변수에 할당되므로 그닥 유용하진 않다</p>\n<h4 id=\"3-3-3-모듈-패턴\" style=\"position:relative;\"><a href=\"#3-3-3-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4\" aria-label=\"3 3 3 모듈 패턴 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-3. 모듈 패턴</h4>\n<p>모듈 패턴은 클래스를 모방한다, 관련이 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만든다</p>\n<ul>\n<li>자바스크립트의 클로저를 기반으로 동작함</li>\n<li>전역변수 억제 및 캡슐화 구현 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">\n  <span class=\"token comment\">//즉시실행 함수의 반환값을 Counter 변수에 할당</span>\n  <span class=\"token keyword\">var</span> Counter <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token comment\">//private 변수, 캡슐화, 정보은닉,</span>\n    <span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 외부로 공개할 데이터, 메서드를 프로퍼티로 추가한 객체를 반환한다</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">increse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">++</span>num<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">decrease</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">--</span>num<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Counter<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span> <span class=\"token comment\">//undefined;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Counter<span class=\"token punctuation\">.</span><span class=\"token function\">increase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Counter<span class=\"token punctuation\">.</span><span class=\"token function\">decrease</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 0</span>\n</code></pre></div>\n<h4 id=\"3-3-4-es6-모듈\" style=\"position:relative;\"><a href=\"#3-3-4-es6-%EB%AA%A8%EB%93%88\" aria-label=\"3 3 4 es6 모듈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3-4. ES6 모듈</h4>\n<p>ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다<br>\n-> 모듈 내의 var 키워드로 선언한 변수는 더이상 전역변수가 아니며, window의 객체 프로퍼티도 아니다</p>\n<ul>\n<li>script 태그에 type=“module” 어트리뷰트를 추가하면, 로드된 자바스크립트 파일은 모듈로서 동작한다.</li>\n<li>모듈의 파일 확장자는 mjs를 권장</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>lib.mjs<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>module<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>app.mjs<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li>ES6는 IE 포함 구형 브라우저에서 동작하지 않는다</li>\n<li>ES6의 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지 브라우저의 ES6 모듈보다는 Webpack등의 모듈 번들러를 사용한다</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-1-%EB%B3%80%EC%88%98\">1-1. 변수</a></p>\n<ul>\n<li><a href=\"#1-1-%EB%B3%80%EC%88%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\">1-1. 변수란 무엇인가? 왜 필요한가?</a></li>\n<li><a href=\"#1-2-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8\">1-2. 변수 선언</a></li>\n<li><a href=\"#1-3-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8%EC%9D%98-%EC%8B%A4%ED%96%89-%EC%8B%9C%EC%A0%90%EA%B3%BC-%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85\">1-3. 변수 선언의 실행 시점과 변수 호이스팅</a></li>\n<li><a href=\"#1-4-%EA%B0%92%EC%9D%98-%ED%95%A0%EB%8B%B9\">1-4. 값의 할당</a></li>\n<li><a href=\"#1-5-%EA%B0%92%EC%9D%98-%EC%9E%AC%ED%95%A0%EB%8B%B9\">1-5. 값의 재할당</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EC%8A%A4%EC%BD%94%ED%94%84\">2. 스코프</a></p>\n<ul>\n<li>\n<p><a href=\"#2-1-%EC%8A%A4%EC%BD%94%ED%94%84%EB%9E%80\">2-1. 스코프란?</a></p>\n<ul>\n<li><a href=\"#2-1-1-%EC%8A%A4%EC%BD%94%ED%94%84%EB%8A%94-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8B%A4\">2-1-1. 스코프는 네임스페이스다.</a></li>\n<li><a href=\"#2-1-2-var-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%A1%9C-%EC%84%A0%EC%96%B8%ED%95%9C-%EB%B3%80%EC%88%98%EC%9D%98-%EC%A4%91%EB%B3%B5%EC%84%A0%EC%96%B8\">2-1-2. var 키워드로 선언한 변수의 중복선언</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-2-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%A2%85%EB%A5%98\">2-2. 스코프 종류</a></p>\n<ul>\n<li><a href=\"#2-2-1-%EC%A0%84%EC%97%AD\">2-2-1. 전역</a></li>\n<li><a href=\"#2-2-2-%EC%A7%80%EC%97%AD\">2-2-2. 지역</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-3-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8\">2-3. 스코프 체인</a></p>\n<ul>\n<li><a href=\"#2-3-1-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8%EC%97%90-%EC%9D%98%ED%95%9C-%EB%B3%80%EC%88%98-%EA%B2%80%EC%83%89\">2-3-1. 스코프 체인에 의한 변수 검색</a></li>\n<li><a href=\"#2-3-2-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8%EC%97%90-%EC%9D%98%ED%95%9C-%ED%95%A8%EC%88%98-%EA%B2%80%EC%83%89\">2-3-2. 스코프 체인에 의한 함수 검색</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-4-%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84\">2-4. 함수 레벨 스코프</a></p>\n</li>\n<li>\n<p><a href=\"#2-5-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84\">2-5. 렉시컬 스코프</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\">3. 전역 변수의 문제점</a></p>\n<ul>\n<li>\n<p><a href=\"#3-1-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0\">3-1. 변수의 생명 주기</a></p>\n<ul>\n<li><a href=\"#3-1-1-%EC%A7%80%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0\">3-1-1. 지역 변수의 생명 주기</a></li>\n<li><a href=\"#3-1-2%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0\">3-1-2.전역 변수의 생명 주기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-2-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\">3-2. 전역 변수의 문제점</a></p>\n</li>\n<li>\n<p><a href=\"#3-3-%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%96%B5%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">3-3. 전역 변수의 사용을 억제하는 방법</a></p>\n<ul>\n<li><a href=\"#3-3-1-%EC%A6%89%EC%8B%9C-%EC%8B%A4%ED%96%89-%ED%95%A8%EC%88%98\">3-3-1. 즉시 실행 함수</a></li>\n<li><a href=\"#3-3-2-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B0%9D%EC%B2%B4\">3-3-2. 네임스페이스 객체</a></li>\n<li><a href=\"#3-3-3-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4\">3-3-3. 모듈 패턴</a></li>\n<li><a href=\"#3-3-4-es6-%EB%AA%A8%EB%93%88\">3-3-4. ES6 모듈</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"2022-10-15","title":"Javascript: 1. 변수와 스코프 (Web 개발자라면 이정도는 알아야지)","categories":"Javascript","author":"sjsjsj1246","emoji":"🖐️"},"fields":{"slug":"/js/1_variable/"}},"site":{"siteMetadata":{"siteUrl":"https://hislogs.com","comments":{"utterances":{"repo":"sjsjsj1246/hislogs"}}}}},"pageContext":{"slug":"/book/plt/1-introduction/","nextSlug":"/effective-typescript/chapter1/","prevSlug":"/js/1_variable/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}